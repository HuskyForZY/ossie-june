// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "cf.h"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_CF_mDataType[] = {
  {"id", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_CF_mDataType
#  undef _0RL_tc_CF_mDataType
#endif
static CORBA::TypeCode_ptr _0RL_tc_CF_mDataType = CORBA::TypeCode::PR_struct_tc("IDL:CF/DataType:1.0", "DataType", _0RL_structmember_CF_mDataType, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_DataType = _0RL_tc_CF_mDataType;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_DataType = _0RL_tc_CF_mDataType;
#endif



static CORBA::TypeCode_ptr _0RL_tc_CF_mInvalidProfile = CORBA::TypeCode::PR_exception_tc("IDL:CF/InvalidProfile:1.0", "InvalidProfile", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_InvalidProfile = _0RL_tc_CF_mInvalidProfile;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_InvalidProfile = _0RL_tc_CF_mInvalidProfile;
#endif






static CORBA::TypeCode_ptr _0RL_tc_CF_mProperties = CORBA::TypeCode::PR_alias_tc("IDL:CF/Properties:1.0", "Properties", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CF_mDataType, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_Properties = _0RL_tc_CF_mProperties;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_Properties = _0RL_tc_CF_mProperties;
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mInvalidObjectReference[] = {
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mInvalidObjectReference = CORBA::TypeCode::PR_exception_tc("IDL:CF/InvalidObjectReference:1.0", "InvalidObjectReference", _0RL_structmember_CF_mInvalidObjectReference, 1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_InvalidObjectReference = _0RL_tc_CF_mInvalidObjectReference;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_InvalidObjectReference = _0RL_tc_CF_mInvalidObjectReference;
#endif


static CORBA::TypeCode_ptr _0RL_tc_CF_mOctetSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/OctetSequence:1.0", "OctetSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_OctetSequence = _0RL_tc_CF_mOctetSequence;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_OctetSequence = _0RL_tc_CF_mOctetSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CF_mStringSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/StringSequence:1.0", "StringSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_StringSequence = _0RL_tc_CF_mStringSequence;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_StringSequence = _0RL_tc_CF_mStringSequence;
#endif


static CORBA::PR_structMember _0RL_structmember_CF_mUnknownProperties[] = {
  {"invalidProperties", _0RL_tc_CF_mProperties}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mUnknownProperties = CORBA::TypeCode::PR_exception_tc("IDL:CF/UnknownProperties:1.0", "UnknownProperties", _0RL_structmember_CF_mUnknownProperties, 1, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_UnknownProperties = _0RL_tc_CF_mUnknownProperties;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_UnknownProperties = _0RL_tc_CF_mUnknownProperties;
#endif


static CORBA::PR_structMember _0RL_structmember_CF_mDeviceAssignmentType[] = {
  {"componentId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"assignedDeviceId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CF_mDeviceAssignmentType
#  undef _0RL_tc_CF_mDeviceAssignmentType
#endif
static CORBA::TypeCode_ptr _0RL_tc_CF_mDeviceAssignmentType = CORBA::TypeCode::PR_struct_tc("IDL:CF/DeviceAssignmentType:1.0", "DeviceAssignmentType", _0RL_structmember_CF_mDeviceAssignmentType, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_DeviceAssignmentType = _0RL_tc_CF_mDeviceAssignmentType;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_DeviceAssignmentType = _0RL_tc_CF_mDeviceAssignmentType;
#endif






static CORBA::TypeCode_ptr _0RL_tc_CF_mDeviceAssignmentSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/DeviceAssignmentSequence:1.0", "DeviceAssignmentSequence", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CF_mDeviceAssignmentType, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_DeviceAssignmentSequence = _0RL_tc_CF_mDeviceAssignmentSequence;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_DeviceAssignmentSequence = _0RL_tc_CF_mDeviceAssignmentSequence;
#endif

static const char* _0RL_enumMember_CF_mErrorNumberType[] = { "CFNOTSET", "CFE2BIG", "CFEACCES", "CFEAGAIN", "CFEBADF", "CFEBADMSG", "CFEBUSY", "CFECANCELED", "CFECHILD", "CFEDEADLK", "CFEDOM", "CFEEXIST", "CFEFAULT", "CFEFBIG", "CFEINPROGRESS", "CFEINTR", "CFEINVAL", "CFEIO", "CFEISDIR", "CFEMFILE", "CFEMLINK", "CFEMSGSIZE", "CFENAMETOOLONG", "CFENFILE", "CFENODEV", "CFENOENT", "CFENOEXEC", "CFENOLCK", "CFENOMEM", "CFENOSPC", "CFENOSYS", "CFENOTDIR", "CFENOTEMPTY", "CFENOTSUP", "CFENOTTY", "CFENXIO", "CFEPERM", "CFEPIPE", "CFERANGE", "CFEROFS", "CFESPIPE", "CFESRCH", "CFETIMEDOUT", "CFEXDEV" };
static CORBA::TypeCode_ptr _0RL_tc_CF_mErrorNumberType = CORBA::TypeCode::PR_enum_tc("IDL:CF/ErrorNumberType:1.0", "ErrorNumberType", _0RL_enumMember_CF_mErrorNumberType, 44, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_ErrorNumberType = _0RL_tc_CF_mErrorNumberType;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_ErrorNumberType = _0RL_tc_CF_mErrorNumberType;
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mInvalidFileName[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mInvalidFileName = CORBA::TypeCode::PR_exception_tc("IDL:CF/InvalidFileName:1.0", "InvalidFileName", _0RL_structmember_CF_mInvalidFileName, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_InvalidFileName = _0RL_tc_CF_mInvalidFileName;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_InvalidFileName = _0RL_tc_CF_mInvalidFileName;
#endif


static CORBA::PR_structMember _0RL_structmember_CF_mFileException[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mFileException = CORBA::TypeCode::PR_exception_tc("IDL:CF/FileException:1.0", "FileException", _0RL_structmember_CF_mFileException, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_FileException = _0RL_tc_CF_mFileException;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_FileException = _0RL_tc_CF_mFileException;
#endif


static CORBA::TypeCode_ptr _0RL_tc_CF_mDeviceSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/DeviceSequence:1.0", "DeviceSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:CF/Device:1.0", "Device", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_DeviceSequence = _0RL_tc_CF_mDeviceSequence;
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_DeviceSequence = _0RL_tc_CF_mDeviceSequence;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_AggregateDevice = CORBA::TypeCode::PR_interface_tc("IDL:CF/AggregateDevice:1.0", "AggregateDevice", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_AggregateDevice = CORBA::TypeCode::PR_interface_tc("IDL:CF/AggregateDevice:1.0", "AggregateDevice", &_0RL_tcTrack);
#endif


static CORBA::PR_structMember _0RL_structmember_CF_mFileSystem_mUnknownFileSystemProperties[] = {
  {"invalidProperties", _0RL_tc_CF_mProperties}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mFileSystem_mUnknownFileSystemProperties = CORBA::TypeCode::PR_exception_tc("IDL:CF/FileSystem/UnknownFileSystemProperties:1.0", "UnknownFileSystemProperties", _0RL_structmember_CF_mFileSystem_mUnknownFileSystemProperties, 1, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::FileSystem::_tc_UnknownFileSystemProperties = _0RL_tc_CF_mFileSystem_mUnknownFileSystemProperties;


static const char* _0RL_enumMember_CF_mFileSystem_mFileType[] = { "PLAIN", "DIRECTORY", "FILE_SYSTEM" };
static CORBA::TypeCode_ptr _0RL_tc_CF_mFileSystem_mFileType = CORBA::TypeCode::PR_enum_tc("IDL:CF/FileSystem/FileType:1.0", "FileType", _0RL_enumMember_CF_mFileSystem_mFileType, 3, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::FileSystem::_tc_FileType = _0RL_tc_CF_mFileSystem_mFileType;


static CORBA::PR_structMember _0RL_structmember_CF_mFileSystem_mFileInformationType[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"kind", _0RL_tc_CF_mFileSystem_mFileType},
  {"size", CORBA::TypeCode::PR_ulonglong_tc()},
  {"fileProperties", _0RL_tc_CF_mProperties}
};

#ifdef _0RL_tc_CF_mFileSystem_mFileInformationType
#  undef _0RL_tc_CF_mFileSystem_mFileInformationType
#endif
static CORBA::TypeCode_ptr _0RL_tc_CF_mFileSystem_mFileInformationType = CORBA::TypeCode::PR_struct_tc("IDL:CF/FileSystem/FileInformationType:1.0", "FileInformationType", _0RL_structmember_CF_mFileSystem_mFileInformationType, 4, &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::FileSystem::_tc_FileInformationType = _0RL_tc_CF_mFileSystem_mFileInformationType;










static CORBA::TypeCode_ptr _0RL_tc_CF_mFileSystem_mFileInformationSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/FileSystem/FileInformationSequence:1.0", "FileInformationSequence", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CF_mFileSystem_mFileInformationType, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::FileSystem::_tc_FileInformationSequence = _0RL_tc_CF_mFileSystem_mFileInformationSequence;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_FileSystem = CORBA::TypeCode::PR_interface_tc("IDL:CF/FileSystem:1.0", "FileSystem", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_FileSystem = CORBA::TypeCode::PR_interface_tc("IDL:CF/FileSystem:1.0", "FileSystem", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mFile_mIOException[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mFile_mIOException = CORBA::TypeCode::PR_exception_tc("IDL:CF/File/IOException:1.0", "IOException", _0RL_structmember_CF_mFile_mIOException, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::File::_tc_IOException = _0RL_tc_CF_mFile_mIOException;



static CORBA::TypeCode_ptr _0RL_tc_CF_mFile_mInvalidFilePointer = CORBA::TypeCode::PR_exception_tc("IDL:CF/File/InvalidFilePointer:1.0", "InvalidFilePointer", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::File::_tc_InvalidFilePointer = _0RL_tc_CF_mFile_mInvalidFilePointer;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_File = CORBA::TypeCode::PR_interface_tc("IDL:CF/File:1.0", "File", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_File = CORBA::TypeCode::PR_interface_tc("IDL:CF/File:1.0", "File", &_0RL_tcTrack);
#endif


static CORBA::TypeCode_ptr _0RL_tc_CF_mResourceFactory_mInvalidResourceId = CORBA::TypeCode::PR_exception_tc("IDL:CF/ResourceFactory/InvalidResourceId:1.0", "InvalidResourceId", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::ResourceFactory::_tc_InvalidResourceId = _0RL_tc_CF_mResourceFactory_mInvalidResourceId;


static CORBA::PR_structMember _0RL_structmember_CF_mResourceFactory_mShutdownFailure[] = {
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mResourceFactory_mShutdownFailure = CORBA::TypeCode::PR_exception_tc("IDL:CF/ResourceFactory/ShutdownFailure:1.0", "ShutdownFailure", _0RL_structmember_CF_mResourceFactory_mShutdownFailure, 1, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::ResourceFactory::_tc_ShutdownFailure = _0RL_tc_CF_mResourceFactory_mShutdownFailure;


static CORBA::PR_structMember _0RL_structmember_CF_mResourceFactory_mCreateResourceFailure[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mResourceFactory_mCreateResourceFailure = CORBA::TypeCode::PR_exception_tc("IDL:CF/ResourceFactory/CreateResourceFailure:1.0", "CreateResourceFailure", _0RL_structmember_CF_mResourceFactory_mCreateResourceFailure, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::ResourceFactory::_tc_CreateResourceFailure = _0RL_tc_CF_mResourceFactory_mCreateResourceFailure;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_ResourceFactory = CORBA::TypeCode::PR_interface_tc("IDL:CF/ResourceFactory:1.0", "ResourceFactory", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_ResourceFactory = CORBA::TypeCode::PR_interface_tc("IDL:CF/ResourceFactory:1.0", "ResourceFactory", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mFileManager_mMountType[] = {
  {"mountPoint", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"fs", CORBA::TypeCode::PR_interface_tc("IDL:CF/FileSystem:1.0", "FileSystem", &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CF_mFileManager_mMountType
#  undef _0RL_tc_CF_mFileManager_mMountType
#endif
static CORBA::TypeCode_ptr _0RL_tc_CF_mFileManager_mMountType = CORBA::TypeCode::PR_struct_tc("IDL:CF/FileManager/MountType:1.0", "MountType", _0RL_structmember_CF_mFileManager_mMountType, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::FileManager::_tc_MountType = _0RL_tc_CF_mFileManager_mMountType;






static CORBA::TypeCode_ptr _0RL_tc_CF_mFileManager_mMountSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/FileManager/MountSequence:1.0", "MountSequence", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CF_mFileManager_mMountType, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::FileManager::_tc_MountSequence = _0RL_tc_CF_mFileManager_mMountSequence;


static CORBA::TypeCode_ptr _0RL_tc_CF_mFileManager_mNonExistentMount = CORBA::TypeCode::PR_exception_tc("IDL:CF/FileManager/NonExistentMount:1.0", "NonExistentMount", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::FileManager::_tc_NonExistentMount = _0RL_tc_CF_mFileManager_mNonExistentMount;



static CORBA::TypeCode_ptr _0RL_tc_CF_mFileManager_mInvalidFileSystem = CORBA::TypeCode::PR_exception_tc("IDL:CF/FileManager/InvalidFileSystem:1.0", "InvalidFileSystem", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::FileManager::_tc_InvalidFileSystem = _0RL_tc_CF_mFileManager_mInvalidFileSystem;



static CORBA::TypeCode_ptr _0RL_tc_CF_mFileManager_mMountPointAlreadyExists = CORBA::TypeCode::PR_exception_tc("IDL:CF/FileManager/MountPointAlreadyExists:1.0", "MountPointAlreadyExists", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::FileManager::_tc_MountPointAlreadyExists = _0RL_tc_CF_mFileManager_mMountPointAlreadyExists;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_FileManager = CORBA::TypeCode::PR_interface_tc("IDL:CF/FileManager:1.0", "FileManager", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_FileManager = CORBA::TypeCode::PR_interface_tc("IDL:CF/FileManager:1.0", "FileManager", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mPort_mInvalidPort[] = {
  {"errorCode", CORBA::TypeCode::PR_ushort_tc()},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mPort_mInvalidPort = CORBA::TypeCode::PR_exception_tc("IDL:CF/Port/InvalidPort:1.0", "InvalidPort", _0RL_structmember_CF_mPort_mInvalidPort, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::Port::_tc_InvalidPort = _0RL_tc_CF_mPort_mInvalidPort;



static CORBA::TypeCode_ptr _0RL_tc_CF_mPort_mOccupiedPort = CORBA::TypeCode::PR_exception_tc("IDL:CF/Port/OccupiedPort:1.0", "OccupiedPort", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::Port::_tc_OccupiedPort = _0RL_tc_CF_mPort_mOccupiedPort;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_Port = CORBA::TypeCode::PR_interface_tc("IDL:CF/Port:1.0", "Port", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_Port = CORBA::TypeCode::PR_interface_tc("IDL:CF/Port:1.0", "Port", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mLifeCycle_mInitializeError[] = {
  {"errorMessages", _0RL_tc_CF_mStringSequence}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mLifeCycle_mInitializeError = CORBA::TypeCode::PR_exception_tc("IDL:CF/LifeCycle/InitializeError:1.0", "InitializeError", _0RL_structmember_CF_mLifeCycle_mInitializeError, 1, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::LifeCycle::_tc_InitializeError = _0RL_tc_CF_mLifeCycle_mInitializeError;


static CORBA::PR_structMember _0RL_structmember_CF_mLifeCycle_mReleaseError[] = {
  {"errorMessages", _0RL_tc_CF_mStringSequence}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mLifeCycle_mReleaseError = CORBA::TypeCode::PR_exception_tc("IDL:CF/LifeCycle/ReleaseError:1.0", "ReleaseError", _0RL_structmember_CF_mLifeCycle_mReleaseError, 1, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::LifeCycle::_tc_ReleaseError = _0RL_tc_CF_mLifeCycle_mReleaseError;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_LifeCycle = CORBA::TypeCode::PR_interface_tc("IDL:CF/LifeCycle:1.0", "LifeCycle", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_LifeCycle = CORBA::TypeCode::PR_interface_tc("IDL:CF/LifeCycle:1.0", "LifeCycle", &_0RL_tcTrack);
#endif


static CORBA::TypeCode_ptr _0RL_tc_CF_mTestableObject_mUnknownTest = CORBA::TypeCode::PR_exception_tc("IDL:CF/TestableObject/UnknownTest:1.0", "UnknownTest", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::TestableObject::_tc_UnknownTest = _0RL_tc_CF_mTestableObject_mUnknownTest;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_TestableObject = CORBA::TypeCode::PR_interface_tc("IDL:CF/TestableObject:1.0", "TestableObject", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_TestableObject = CORBA::TypeCode::PR_interface_tc("IDL:CF/TestableObject:1.0", "TestableObject", &_0RL_tcTrack);
#endif


static CORBA::PR_structMember _0RL_structmember_CF_mPropertySet_mInvalidConfiguration[] = {
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"invalidProperties", _0RL_tc_CF_mProperties}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mPropertySet_mInvalidConfiguration = CORBA::TypeCode::PR_exception_tc("IDL:CF/PropertySet/InvalidConfiguration:1.0", "InvalidConfiguration", _0RL_structmember_CF_mPropertySet_mInvalidConfiguration, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::PropertySet::_tc_InvalidConfiguration = _0RL_tc_CF_mPropertySet_mInvalidConfiguration;



static CORBA::PR_structMember _0RL_structmember_CF_mPropertySet_mPartialConfiguration[] = {
  {"invalidProperties", _0RL_tc_CF_mProperties}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mPropertySet_mPartialConfiguration = CORBA::TypeCode::PR_exception_tc("IDL:CF/PropertySet/PartialConfiguration:1.0", "PartialConfiguration", _0RL_structmember_CF_mPropertySet_mPartialConfiguration, 1, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::PropertySet::_tc_PartialConfiguration = _0RL_tc_CF_mPropertySet_mPartialConfiguration;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_PropertySet = CORBA::TypeCode::PR_interface_tc("IDL:CF/PropertySet:1.0", "PropertySet", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_PropertySet = CORBA::TypeCode::PR_interface_tc("IDL:CF/PropertySet:1.0", "PropertySet", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mDomainManager_mApplicationInstallationError[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mApplicationInstallationError = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/ApplicationInstallationError:1.0", "ApplicationInstallationError", _0RL_structmember_CF_mDomainManager_mApplicationInstallationError, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_ApplicationInstallationError = _0RL_tc_CF_mDomainManager_mApplicationInstallationError;


static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mApplicationSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/DomainManager/ApplicationSequence:1.0", "ApplicationSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:CF/Application:1.0", "Application", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::DomainManager::_tc_ApplicationSequence = _0RL_tc_CF_mDomainManager_mApplicationSequence;

static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mApplicationFactorySequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/DomainManager/ApplicationFactorySequence:1.0", "ApplicationFactorySequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:CF/ApplicationFactory:1.0", "ApplicationFactory", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::DomainManager::_tc_ApplicationFactorySequence = _0RL_tc_CF_mDomainManager_mApplicationFactorySequence;

static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mDeviceManagerSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/DomainManager/DeviceManagerSequence:1.0", "DeviceManagerSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:CF/DeviceManager:1.0", "DeviceManager", &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::DomainManager::_tc_DeviceManagerSequence = _0RL_tc_CF_mDomainManager_mDeviceManagerSequence;


static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mInvalidIdentifier = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/InvalidIdentifier:1.0", "InvalidIdentifier", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_InvalidIdentifier = _0RL_tc_CF_mDomainManager_mInvalidIdentifier;



static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mDeviceManagerNotRegistered = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/DeviceManagerNotRegistered:1.0", "DeviceManagerNotRegistered", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_DeviceManagerNotRegistered = _0RL_tc_CF_mDomainManager_mDeviceManagerNotRegistered;


static CORBA::PR_structMember _0RL_structmember_CF_mDomainManager_mApplicationUninstallationError[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mApplicationUninstallationError = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/ApplicationUninstallationError:1.0", "ApplicationUninstallationError", _0RL_structmember_CF_mDomainManager_mApplicationUninstallationError, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_ApplicationUninstallationError = _0RL_tc_CF_mDomainManager_mApplicationUninstallationError;


static CORBA::PR_structMember _0RL_structmember_CF_mDomainManager_mRegisterError[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mRegisterError = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/RegisterError:1.0", "RegisterError", _0RL_structmember_CF_mDomainManager_mRegisterError, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_RegisterError = _0RL_tc_CF_mDomainManager_mRegisterError;


static CORBA::PR_structMember _0RL_structmember_CF_mDomainManager_mUnregisterError[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mUnregisterError = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/UnregisterError:1.0", "UnregisterError", _0RL_structmember_CF_mDomainManager_mUnregisterError, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_UnregisterError = _0RL_tc_CF_mDomainManager_mUnregisterError;



static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mAlreadyConnected = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/AlreadyConnected:1.0", "AlreadyConnected", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_AlreadyConnected = _0RL_tc_CF_mDomainManager_mAlreadyConnected;



static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mInvalidEventChannelName = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/InvalidEventChannelName:1.0", "InvalidEventChannelName", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_InvalidEventChannelName = _0RL_tc_CF_mDomainManager_mInvalidEventChannelName;



static CORBA::TypeCode_ptr _0RL_tc_CF_mDomainManager_mNotConnected = CORBA::TypeCode::PR_exception_tc("IDL:CF/DomainManager/NotConnected:1.0", "NotConnected", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::DomainManager::_tc_NotConnected = _0RL_tc_CF_mDomainManager_mNotConnected;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_DomainManager = CORBA::TypeCode::PR_interface_tc("IDL:CF/DomainManager:1.0", "DomainManager", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_DomainManager = CORBA::TypeCode::PR_interface_tc("IDL:CF/DomainManager:1.0", "DomainManager", &_0RL_tcTrack);
#endif


static CORBA::PR_structMember _0RL_structmember_CF_mApplicationFactory_mCreateApplicationRequestError[] = {
  {"invalidAssignments", _0RL_tc_CF_mDeviceAssignmentSequence}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mApplicationFactory_mCreateApplicationRequestError = CORBA::TypeCode::PR_exception_tc("IDL:CF/ApplicationFactory/CreateApplicationRequestError:1.0", "CreateApplicationRequestError", _0RL_structmember_CF_mApplicationFactory_mCreateApplicationRequestError, 1, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::ApplicationFactory::_tc_CreateApplicationRequestError = _0RL_tc_CF_mApplicationFactory_mCreateApplicationRequestError;


static CORBA::PR_structMember _0RL_structmember_CF_mApplicationFactory_mCreateApplicationError[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mApplicationFactory_mCreateApplicationError = CORBA::TypeCode::PR_exception_tc("IDL:CF/ApplicationFactory/CreateApplicationError:1.0", "CreateApplicationError", _0RL_structmember_CF_mApplicationFactory_mCreateApplicationError, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::ApplicationFactory::_tc_CreateApplicationError = _0RL_tc_CF_mApplicationFactory_mCreateApplicationError;



static CORBA::PR_structMember _0RL_structmember_CF_mApplicationFactory_mInvalidInitConfiguration[] = {
  {"invalidProperties", _0RL_tc_CF_mProperties}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mApplicationFactory_mInvalidInitConfiguration = CORBA::TypeCode::PR_exception_tc("IDL:CF/ApplicationFactory/InvalidInitConfiguration:1.0", "InvalidInitConfiguration", _0RL_structmember_CF_mApplicationFactory_mInvalidInitConfiguration, 1, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::ApplicationFactory::_tc_InvalidInitConfiguration = _0RL_tc_CF_mApplicationFactory_mInvalidInitConfiguration;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_ApplicationFactory = CORBA::TypeCode::PR_interface_tc("IDL:CF/ApplicationFactory:1.0", "ApplicationFactory", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_ApplicationFactory = CORBA::TypeCode::PR_interface_tc("IDL:CF/ApplicationFactory:1.0", "ApplicationFactory", &_0RL_tcTrack);
#endif


static CORBA::TypeCode_ptr _0RL_tc_CF_mPortSupplier_mUnknownPort = CORBA::TypeCode::PR_exception_tc("IDL:CF/PortSupplier/UnknownPort:1.0", "UnknownPort", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::PortSupplier::_tc_UnknownPort = _0RL_tc_CF_mPortSupplier_mUnknownPort;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_PortSupplier = CORBA::TypeCode::PR_interface_tc("IDL:CF/PortSupplier:1.0", "PortSupplier", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_PortSupplier = CORBA::TypeCode::PR_interface_tc("IDL:CF/PortSupplier:1.0", "PortSupplier", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mResource_mStartError[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mResource_mStartError = CORBA::TypeCode::PR_exception_tc("IDL:CF/Resource/StartError:1.0", "StartError", _0RL_structmember_CF_mResource_mStartError, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::Resource::_tc_StartError = _0RL_tc_CF_mResource_mStartError;


static CORBA::PR_structMember _0RL_structmember_CF_mResource_mStopError[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mResource_mStopError = CORBA::TypeCode::PR_exception_tc("IDL:CF/Resource/StopError:1.0", "StopError", _0RL_structmember_CF_mResource_mStopError, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::Resource::_tc_StopError = _0RL_tc_CF_mResource_mStopError;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_Resource = CORBA::TypeCode::PR_interface_tc("IDL:CF/Resource:1.0", "Resource", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_Resource = CORBA::TypeCode::PR_interface_tc("IDL:CF/Resource:1.0", "Resource", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mDevice_mInvalidState[] = {
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mDevice_mInvalidState = CORBA::TypeCode::PR_exception_tc("IDL:CF/Device/InvalidState:1.0", "InvalidState", _0RL_structmember_CF_mDevice_mInvalidState, 1, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::Device::_tc_InvalidState = _0RL_tc_CF_mDevice_mInvalidState;



static CORBA::PR_structMember _0RL_structmember_CF_mDevice_mInvalidCapacity[] = {
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"capacities", _0RL_tc_CF_mProperties}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mDevice_mInvalidCapacity = CORBA::TypeCode::PR_exception_tc("IDL:CF/Device/InvalidCapacity:1.0", "InvalidCapacity", _0RL_structmember_CF_mDevice_mInvalidCapacity, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::Device::_tc_InvalidCapacity = _0RL_tc_CF_mDevice_mInvalidCapacity;


static const char* _0RL_enumMember_CF_mDevice_mAdminType[] = { "LOCKED", "SHUTTING_DOWN", "UNLOCKED" };
static CORBA::TypeCode_ptr _0RL_tc_CF_mDevice_mAdminType = CORBA::TypeCode::PR_enum_tc("IDL:CF/Device/AdminType:1.0", "AdminType", _0RL_enumMember_CF_mDevice_mAdminType, 3, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::Device::_tc_AdminType = _0RL_tc_CF_mDevice_mAdminType;

static const char* _0RL_enumMember_CF_mDevice_mOperationalType[] = { "ENABLED", "DISABLED" };
static CORBA::TypeCode_ptr _0RL_tc_CF_mDevice_mOperationalType = CORBA::TypeCode::PR_enum_tc("IDL:CF/Device/OperationalType:1.0", "OperationalType", _0RL_enumMember_CF_mDevice_mOperationalType, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::Device::_tc_OperationalType = _0RL_tc_CF_mDevice_mOperationalType;

static const char* _0RL_enumMember_CF_mDevice_mUsageType[] = { "IDLE", "ACTIVE", "BUSY" };
static CORBA::TypeCode_ptr _0RL_tc_CF_mDevice_mUsageType = CORBA::TypeCode::PR_enum_tc("IDL:CF/Device/UsageType:1.0", "UsageType", _0RL_enumMember_CF_mDevice_mUsageType, 3, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::Device::_tc_UsageType = _0RL_tc_CF_mDevice_mUsageType;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_Device = CORBA::TypeCode::PR_interface_tc("IDL:CF/Device:1.0", "Device", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_Device = CORBA::TypeCode::PR_interface_tc("IDL:CF/Device:1.0", "Device", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mApplication_mComponentProcessIdType[] = {
  {"componentId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"processId", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_CF_mApplication_mComponentProcessIdType
#  undef _0RL_tc_CF_mApplication_mComponentProcessIdType
#endif
static CORBA::TypeCode_ptr _0RL_tc_CF_mApplication_mComponentProcessIdType = CORBA::TypeCode::PR_struct_tc("IDL:CF/Application/ComponentProcessIdType:1.0", "ComponentProcessIdType", _0RL_structmember_CF_mApplication_mComponentProcessIdType, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::Application::_tc_ComponentProcessIdType = _0RL_tc_CF_mApplication_mComponentProcessIdType;






static CORBA::TypeCode_ptr _0RL_tc_CF_mApplication_mComponentProcessIdSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/Application/ComponentProcessIdSequence:1.0", "ComponentProcessIdSequence", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CF_mApplication_mComponentProcessIdType, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::Application::_tc_ComponentProcessIdSequence = _0RL_tc_CF_mApplication_mComponentProcessIdSequence;

static CORBA::PR_structMember _0RL_structmember_CF_mApplication_mComponentElementType[] = {
  {"componentId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"elementId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CF_mApplication_mComponentElementType
#  undef _0RL_tc_CF_mApplication_mComponentElementType
#endif
static CORBA::TypeCode_ptr _0RL_tc_CF_mApplication_mComponentElementType = CORBA::TypeCode::PR_struct_tc("IDL:CF/Application/ComponentElementType:1.0", "ComponentElementType", _0RL_structmember_CF_mApplication_mComponentElementType, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::Application::_tc_ComponentElementType = _0RL_tc_CF_mApplication_mComponentElementType;






static CORBA::TypeCode_ptr _0RL_tc_CF_mApplication_mComponentElementSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/Application/ComponentElementSequence:1.0", "ComponentElementSequence", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CF_mApplication_mComponentElementType, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::Application::_tc_ComponentElementSequence = _0RL_tc_CF_mApplication_mComponentElementSequence;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_Application = CORBA::TypeCode::PR_interface_tc("IDL:CF/Application:1.0", "Application", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_Application = CORBA::TypeCode::PR_interface_tc("IDL:CF/Application:1.0", "Application", &_0RL_tcTrack);
#endif

static const char* _0RL_enumMember_CF_mLoadableDevice_mLoadType[] = { "KERNEL_MODULE", "DRIVER", "SHARED_LIBRARY", "EXECUTABLE" };
static CORBA::TypeCode_ptr _0RL_tc_CF_mLoadableDevice_mLoadType = CORBA::TypeCode::PR_enum_tc("IDL:CF/LoadableDevice/LoadType:1.0", "LoadType", _0RL_enumMember_CF_mLoadableDevice_mLoadType, 4, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::LoadableDevice::_tc_LoadType = _0RL_tc_CF_mLoadableDevice_mLoadType;


static CORBA::TypeCode_ptr _0RL_tc_CF_mLoadableDevice_mInvalidLoadKind = CORBA::TypeCode::PR_exception_tc("IDL:CF/LoadableDevice/InvalidLoadKind:1.0", "InvalidLoadKind", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::LoadableDevice::_tc_InvalidLoadKind = _0RL_tc_CF_mLoadableDevice_mInvalidLoadKind;


static CORBA::PR_structMember _0RL_structmember_CF_mLoadableDevice_mLoadFail[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mLoadableDevice_mLoadFail = CORBA::TypeCode::PR_exception_tc("IDL:CF/LoadableDevice/LoadFail:1.0", "LoadFail", _0RL_structmember_CF_mLoadableDevice_mLoadFail, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::LoadableDevice::_tc_LoadFail = _0RL_tc_CF_mLoadableDevice_mLoadFail;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_LoadableDevice = CORBA::TypeCode::PR_interface_tc("IDL:CF/LoadableDevice:1.0", "LoadableDevice", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_LoadableDevice = CORBA::TypeCode::PR_interface_tc("IDL:CF/LoadableDevice:1.0", "LoadableDevice", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mExecutableDevice_mInvalidProcess[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mExecutableDevice_mInvalidProcess = CORBA::TypeCode::PR_exception_tc("IDL:CF/ExecutableDevice/InvalidProcess:1.0", "InvalidProcess", _0RL_structmember_CF_mExecutableDevice_mInvalidProcess, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::ExecutableDevice::_tc_InvalidProcess = _0RL_tc_CF_mExecutableDevice_mInvalidProcess;



static CORBA::TypeCode_ptr _0RL_tc_CF_mExecutableDevice_mInvalidFunction = CORBA::TypeCode::PR_exception_tc("IDL:CF/ExecutableDevice/InvalidFunction:1.0", "InvalidFunction", (CORBA::PR_structMember*) 0, 0, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::ExecutableDevice::_tc_InvalidFunction = _0RL_tc_CF_mExecutableDevice_mInvalidFunction;


static CORBA::TypeCode_ptr _0RL_tc_CF_mExecutableDevice_mProcessID__Type = CORBA::TypeCode::PR_alias_tc("IDL:CF/ExecutableDevice/ProcessID_Type:1.0", "ProcessID_Type", CORBA::TypeCode::PR_ulong_tc(), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::ExecutableDevice::_tc_ProcessID_Type = _0RL_tc_CF_mExecutableDevice_mProcessID__Type;


static CORBA::PR_structMember _0RL_structmember_CF_mExecutableDevice_mInvalidParameters[] = {
  {"invalidParms", _0RL_tc_CF_mProperties}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mExecutableDevice_mInvalidParameters = CORBA::TypeCode::PR_exception_tc("IDL:CF/ExecutableDevice/InvalidParameters:1.0", "InvalidParameters", _0RL_structmember_CF_mExecutableDevice_mInvalidParameters, 1, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::ExecutableDevice::_tc_InvalidParameters = _0RL_tc_CF_mExecutableDevice_mInvalidParameters;



static CORBA::PR_structMember _0RL_structmember_CF_mExecutableDevice_mInvalidOptions[] = {
  {"invalidOpts", _0RL_tc_CF_mProperties}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mExecutableDevice_mInvalidOptions = CORBA::TypeCode::PR_exception_tc("IDL:CF/ExecutableDevice/InvalidOptions:1.0", "InvalidOptions", _0RL_structmember_CF_mExecutableDevice_mInvalidOptions, 1, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::ExecutableDevice::_tc_InvalidOptions = _0RL_tc_CF_mExecutableDevice_mInvalidOptions;


static CORBA::PR_structMember _0RL_structmember_CF_mExecutableDevice_mExecuteFail[] = {
  {"errorNumber", _0RL_tc_CF_mErrorNumberType},
  {"msg", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

static CORBA::TypeCode_ptr _0RL_tc_CF_mExecutableDevice_mExecuteFail = CORBA::TypeCode::PR_exception_tc("IDL:CF/ExecutableDevice/ExecuteFail:1.0", "ExecuteFail", _0RL_structmember_CF_mExecutableDevice_mExecuteFail, 2, &_0RL_tcTrack);
const CORBA::TypeCode_ptr CF::ExecutableDevice::_tc_ExecuteFail = _0RL_tc_CF_mExecutableDevice_mExecuteFail;


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_ExecutableDevice = CORBA::TypeCode::PR_interface_tc("IDL:CF/ExecutableDevice:1.0", "ExecutableDevice", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_ExecutableDevice = CORBA::TypeCode::PR_interface_tc("IDL:CF/ExecutableDevice:1.0", "ExecutableDevice", &_0RL_tcTrack);
#endif

static CORBA::PR_structMember _0RL_structmember_CF_mDeviceManager_mServiceType[] = {
  {"serviceObject", CORBA::TypeCode::PR_Object_tc()},
  {"serviceName", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_CF_mDeviceManager_mServiceType
#  undef _0RL_tc_CF_mDeviceManager_mServiceType
#endif
static CORBA::TypeCode_ptr _0RL_tc_CF_mDeviceManager_mServiceType = CORBA::TypeCode::PR_struct_tc("IDL:CF/DeviceManager/ServiceType:1.0", "ServiceType", _0RL_structmember_CF_mDeviceManager_mServiceType, 2, &_0RL_tcTrack);

const CORBA::TypeCode_ptr CF::DeviceManager::_tc_ServiceType = _0RL_tc_CF_mDeviceManager_mServiceType;






static CORBA::TypeCode_ptr _0RL_tc_CF_mDeviceManager_mServiceSequence = CORBA::TypeCode::PR_alias_tc("IDL:CF/DeviceManager/ServiceSequence:1.0", "ServiceSequence", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CF_mDeviceManager_mServiceType, &_0RL_tcTrack), &_0RL_tcTrack);


const CORBA::TypeCode_ptr CF::DeviceManager::_tc_ServiceSequence = _0RL_tc_CF_mDeviceManager_mServiceSequence;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace CF { 
  const ::CORBA::TypeCode_ptr _tc_DeviceManager = CORBA::TypeCode::PR_interface_tc("IDL:CF/DeviceManager:1.0", "DeviceManager", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr CF::_tc_DeviceManager = CORBA::TypeCode::PR_interface_tc("IDL:CF/DeviceManager:1.0", "DeviceManager", &_0RL_tcTrack);
#endif

static void _0RL_CF_mDataType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DataType* _p = (CF::DataType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDataType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DataType* _p = new CF::DataType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDataType_destructor_fn(void* _v)
{
  CF::DataType* _p = (CF::DataType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DataType& _s)
{
  CF::DataType* _p = new CF::DataType(_s);
  _a.PR_insert(_0RL_tc_CF_mDataType,
               _0RL_CF_mDataType_marshal_fn,
               _0RL_CF_mDataType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DataType* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDataType,
               _0RL_CF_mDataType_marshal_fn,
               _0RL_CF_mDataType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DataType*& _sp)
{
  return _a >>= (const CF::DataType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DataType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDataType,
                    _0RL_CF_mDataType_unmarshal_fn,
                    _0RL_CF_mDataType_marshal_fn,
                    _0RL_CF_mDataType_destructor_fn,
                    _v)) {
    _sp = (const CF::DataType*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_CF_mInvalidProfile_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::InvalidProfile* _p = (const CF::InvalidProfile*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mInvalidProfile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::InvalidProfile* _p = new CF::InvalidProfile;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mInvalidProfile_destructor_fn(void* _v)
{
  CF::InvalidProfile* _p = (CF::InvalidProfile*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::InvalidProfile& _s)
{
  CF::InvalidProfile* _p = new CF::InvalidProfile(_s);
  _a.PR_insert(_0RL_tc_CF_mInvalidProfile,
               _0RL_CF_mInvalidProfile_marshal_fn,
               _0RL_CF_mInvalidProfile_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::InvalidProfile* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mInvalidProfile,
               _0RL_CF_mInvalidProfile_marshal_fn,
               _0RL_CF_mInvalidProfile_destructor_fn,
               (CF::InvalidProfile*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidProfile*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mInvalidProfile,
                    _0RL_CF_mInvalidProfile_unmarshal_fn,
                    _0RL_CF_mInvalidProfile_marshal_fn,
                    _0RL_CF_mInvalidProfile_destructor_fn,
                    _v)) {
    _sp = (const CF::InvalidProfile*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mInvalidProfile(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::InvalidProfile & _ex = (const CF::InvalidProfile &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mInvalidProfile (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::InvalidProfile* _ex = (const CF::InvalidProfile*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mInvalidProfile {
public:
  _0RL_insertToAny_Singleton__cCF_mInvalidProfile() {
    CF::InvalidProfile::insertToAnyFn = _0RL_insertToAny__cCF_mInvalidProfile;
    CF::InvalidProfile::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mInvalidProfile;
  }
};
static _0RL_insertToAny_Singleton__cCF_mInvalidProfile _0RL_insertToAny_Singleton__cCF_mInvalidProfile_;

static void _0RL_CF_mProperties_marshal_fn(cdrStream& _s, void* _v)
{
  CF::Properties* _p = (CF::Properties*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mProperties_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Properties* _p = new CF::Properties;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mProperties_destructor_fn(void* _v)
{
  CF::Properties* _p = (CF::Properties*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Properties& _s)
{
  CF::Properties* _p = new CF::Properties(_s);
  _a.PR_insert(_0RL_tc_CF_mProperties,
               _0RL_CF_mProperties_marshal_fn,
               _0RL_CF_mProperties_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::Properties* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mProperties,
               _0RL_CF_mProperties_marshal_fn,
               _0RL_CF_mProperties_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Properties*& _sp)
{
  return _a >>= (const CF::Properties*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Properties*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mProperties,
                    _0RL_CF_mProperties_unmarshal_fn,
                    _0RL_CF_mProperties_marshal_fn,
                    _0RL_CF_mProperties_destructor_fn,
                    _v)) {
    _sp = (const CF::Properties*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_CF_mInvalidObjectReference_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::InvalidObjectReference* _p = (const CF::InvalidObjectReference*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mInvalidObjectReference_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::InvalidObjectReference* _p = new CF::InvalidObjectReference;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mInvalidObjectReference_destructor_fn(void* _v)
{
  CF::InvalidObjectReference* _p = (CF::InvalidObjectReference*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::InvalidObjectReference& _s)
{
  CF::InvalidObjectReference* _p = new CF::InvalidObjectReference(_s);
  _a.PR_insert(_0RL_tc_CF_mInvalidObjectReference,
               _0RL_CF_mInvalidObjectReference_marshal_fn,
               _0RL_CF_mInvalidObjectReference_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::InvalidObjectReference* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mInvalidObjectReference,
               _0RL_CF_mInvalidObjectReference_marshal_fn,
               _0RL_CF_mInvalidObjectReference_destructor_fn,
               (CF::InvalidObjectReference*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidObjectReference*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mInvalidObjectReference,
                    _0RL_CF_mInvalidObjectReference_unmarshal_fn,
                    _0RL_CF_mInvalidObjectReference_marshal_fn,
                    _0RL_CF_mInvalidObjectReference_destructor_fn,
                    _v)) {
    _sp = (const CF::InvalidObjectReference*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mInvalidObjectReference(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::InvalidObjectReference & _ex = (const CF::InvalidObjectReference &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mInvalidObjectReference (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::InvalidObjectReference* _ex = (const CF::InvalidObjectReference*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mInvalidObjectReference {
public:
  _0RL_insertToAny_Singleton__cCF_mInvalidObjectReference() {
    CF::InvalidObjectReference::insertToAnyFn = _0RL_insertToAny__cCF_mInvalidObjectReference;
    CF::InvalidObjectReference::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mInvalidObjectReference;
  }
};
static _0RL_insertToAny_Singleton__cCF_mInvalidObjectReference _0RL_insertToAny_Singleton__cCF_mInvalidObjectReference_;

static void _0RL_CF_mOctetSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::OctetSequence* _p = (CF::OctetSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mOctetSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::OctetSequence* _p = new CF::OctetSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mOctetSequence_destructor_fn(void* _v)
{
  CF::OctetSequence* _p = (CF::OctetSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::OctetSequence& _s)
{
  CF::OctetSequence* _p = new CF::OctetSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mOctetSequence,
               _0RL_CF_mOctetSequence_marshal_fn,
               _0RL_CF_mOctetSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::OctetSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mOctetSequence,
               _0RL_CF_mOctetSequence_marshal_fn,
               _0RL_CF_mOctetSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::OctetSequence*& _sp)
{
  return _a >>= (const CF::OctetSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::OctetSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mOctetSequence,
                    _0RL_CF_mOctetSequence_unmarshal_fn,
                    _0RL_CF_mOctetSequence_marshal_fn,
                    _0RL_CF_mOctetSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::OctetSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mStringSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::StringSequence* _p = (CF::StringSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mStringSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::StringSequence* _p = new CF::StringSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mStringSequence_destructor_fn(void* _v)
{
  CF::StringSequence* _p = (CF::StringSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::StringSequence& _s)
{
  CF::StringSequence* _p = new CF::StringSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mStringSequence,
               _0RL_CF_mStringSequence_marshal_fn,
               _0RL_CF_mStringSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::StringSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mStringSequence,
               _0RL_CF_mStringSequence_marshal_fn,
               _0RL_CF_mStringSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::StringSequence*& _sp)
{
  return _a >>= (const CF::StringSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::StringSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mStringSequence,
                    _0RL_CF_mStringSequence_unmarshal_fn,
                    _0RL_CF_mStringSequence_marshal_fn,
                    _0RL_CF_mStringSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::StringSequence*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_CF_mUnknownProperties_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::UnknownProperties* _p = (const CF::UnknownProperties*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mUnknownProperties_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::UnknownProperties* _p = new CF::UnknownProperties;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mUnknownProperties_destructor_fn(void* _v)
{
  CF::UnknownProperties* _p = (CF::UnknownProperties*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::UnknownProperties& _s)
{
  CF::UnknownProperties* _p = new CF::UnknownProperties(_s);
  _a.PR_insert(_0RL_tc_CF_mUnknownProperties,
               _0RL_CF_mUnknownProperties_marshal_fn,
               _0RL_CF_mUnknownProperties_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::UnknownProperties* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mUnknownProperties,
               _0RL_CF_mUnknownProperties_marshal_fn,
               _0RL_CF_mUnknownProperties_destructor_fn,
               (CF::UnknownProperties*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::UnknownProperties*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mUnknownProperties,
                    _0RL_CF_mUnknownProperties_unmarshal_fn,
                    _0RL_CF_mUnknownProperties_marshal_fn,
                    _0RL_CF_mUnknownProperties_destructor_fn,
                    _v)) {
    _sp = (const CF::UnknownProperties*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mUnknownProperties(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::UnknownProperties & _ex = (const CF::UnknownProperties &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mUnknownProperties (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::UnknownProperties* _ex = (const CF::UnknownProperties*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mUnknownProperties {
public:
  _0RL_insertToAny_Singleton__cCF_mUnknownProperties() {
    CF::UnknownProperties::insertToAnyFn = _0RL_insertToAny__cCF_mUnknownProperties;
    CF::UnknownProperties::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mUnknownProperties;
  }
};
static _0RL_insertToAny_Singleton__cCF_mUnknownProperties _0RL_insertToAny_Singleton__cCF_mUnknownProperties_;

static void _0RL_CF_mDeviceAssignmentType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DeviceAssignmentType* _p = (CF::DeviceAssignmentType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDeviceAssignmentType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DeviceAssignmentType* _p = new CF::DeviceAssignmentType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDeviceAssignmentType_destructor_fn(void* _v)
{
  CF::DeviceAssignmentType* _p = (CF::DeviceAssignmentType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DeviceAssignmentType& _s)
{
  CF::DeviceAssignmentType* _p = new CF::DeviceAssignmentType(_s);
  _a.PR_insert(_0RL_tc_CF_mDeviceAssignmentType,
               _0RL_CF_mDeviceAssignmentType_marshal_fn,
               _0RL_CF_mDeviceAssignmentType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DeviceAssignmentType* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDeviceAssignmentType,
               _0RL_CF_mDeviceAssignmentType_marshal_fn,
               _0RL_CF_mDeviceAssignmentType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceAssignmentType*& _sp)
{
  return _a >>= (const CF::DeviceAssignmentType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceAssignmentType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDeviceAssignmentType,
                    _0RL_CF_mDeviceAssignmentType_unmarshal_fn,
                    _0RL_CF_mDeviceAssignmentType_marshal_fn,
                    _0RL_CF_mDeviceAssignmentType_destructor_fn,
                    _v)) {
    _sp = (const CF::DeviceAssignmentType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mDeviceAssignmentSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DeviceAssignmentSequence* _p = (CF::DeviceAssignmentSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDeviceAssignmentSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DeviceAssignmentSequence* _p = new CF::DeviceAssignmentSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDeviceAssignmentSequence_destructor_fn(void* _v)
{
  CF::DeviceAssignmentSequence* _p = (CF::DeviceAssignmentSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DeviceAssignmentSequence& _s)
{
  CF::DeviceAssignmentSequence* _p = new CF::DeviceAssignmentSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mDeviceAssignmentSequence,
               _0RL_CF_mDeviceAssignmentSequence_marshal_fn,
               _0RL_CF_mDeviceAssignmentSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DeviceAssignmentSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDeviceAssignmentSequence,
               _0RL_CF_mDeviceAssignmentSequence_marshal_fn,
               _0RL_CF_mDeviceAssignmentSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceAssignmentSequence*& _sp)
{
  return _a >>= (const CF::DeviceAssignmentSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceAssignmentSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDeviceAssignmentSequence,
                    _0RL_CF_mDeviceAssignmentSequence_unmarshal_fn,
                    _0RL_CF_mDeviceAssignmentSequence_marshal_fn,
                    _0RL_CF_mDeviceAssignmentSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::DeviceAssignmentSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mErrorNumberType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::ErrorNumberType* _p = (CF::ErrorNumberType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mErrorNumberType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ErrorNumberType* _p = (CF::ErrorNumberType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CF::ErrorNumberType _s)
{
  _a.PR_insert(_0RL_tc_CF_mErrorNumberType,
               _0RL_CF_mErrorNumberType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::ErrorNumberType& _s)
{
  return _a.PR_extract(_0RL_tc_CF_mErrorNumberType,
                       _0RL_CF_mErrorNumberType_unmarshal_fn,
                       &_s);
}


static void _0RL_CF_mInvalidFileName_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::InvalidFileName* _p = (const CF::InvalidFileName*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mInvalidFileName_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::InvalidFileName* _p = new CF::InvalidFileName;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mInvalidFileName_destructor_fn(void* _v)
{
  CF::InvalidFileName* _p = (CF::InvalidFileName*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::InvalidFileName& _s)
{
  CF::InvalidFileName* _p = new CF::InvalidFileName(_s);
  _a.PR_insert(_0RL_tc_CF_mInvalidFileName,
               _0RL_CF_mInvalidFileName_marshal_fn,
               _0RL_CF_mInvalidFileName_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::InvalidFileName* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mInvalidFileName,
               _0RL_CF_mInvalidFileName_marshal_fn,
               _0RL_CF_mInvalidFileName_destructor_fn,
               (CF::InvalidFileName*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidFileName*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mInvalidFileName,
                    _0RL_CF_mInvalidFileName_unmarshal_fn,
                    _0RL_CF_mInvalidFileName_marshal_fn,
                    _0RL_CF_mInvalidFileName_destructor_fn,
                    _v)) {
    _sp = (const CF::InvalidFileName*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mInvalidFileName(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::InvalidFileName & _ex = (const CF::InvalidFileName &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mInvalidFileName (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::InvalidFileName* _ex = (const CF::InvalidFileName*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mInvalidFileName {
public:
  _0RL_insertToAny_Singleton__cCF_mInvalidFileName() {
    CF::InvalidFileName::insertToAnyFn = _0RL_insertToAny__cCF_mInvalidFileName;
    CF::InvalidFileName::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mInvalidFileName;
  }
};
static _0RL_insertToAny_Singleton__cCF_mInvalidFileName _0RL_insertToAny_Singleton__cCF_mInvalidFileName_;


static void _0RL_CF_mFileException_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::FileException* _p = (const CF::FileException*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileException_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileException* _p = new CF::FileException;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileException_destructor_fn(void* _v)
{
  CF::FileException* _p = (CF::FileException*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileException& _s)
{
  CF::FileException* _p = new CF::FileException(_s);
  _a.PR_insert(_0RL_tc_CF_mFileException,
               _0RL_CF_mFileException_marshal_fn,
               _0RL_CF_mFileException_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::FileException* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileException,
               _0RL_CF_mFileException_marshal_fn,
               _0RL_CF_mFileException_destructor_fn,
               (CF::FileException*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileException*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileException,
                    _0RL_CF_mFileException_unmarshal_fn,
                    _0RL_CF_mFileException_marshal_fn,
                    _0RL_CF_mFileException_destructor_fn,
                    _v)) {
    _sp = (const CF::FileException*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mFileException(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::FileException & _ex = (const CF::FileException &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mFileException (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::FileException* _ex = (const CF::FileException*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mFileException {
public:
  _0RL_insertToAny_Singleton__cCF_mFileException() {
    CF::FileException::insertToAnyFn = _0RL_insertToAny__cCF_mFileException;
    CF::FileException::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mFileException;
  }
};
static _0RL_insertToAny_Singleton__cCF_mFileException _0RL_insertToAny_Singleton__cCF_mFileException_;

static void _0RL_CF_mDeviceSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DeviceSequence* _p = (CF::DeviceSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDeviceSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DeviceSequence* _p = new CF::DeviceSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDeviceSequence_destructor_fn(void* _v)
{
  CF::DeviceSequence* _p = (CF::DeviceSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DeviceSequence& _s)
{
  CF::DeviceSequence* _p = new CF::DeviceSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mDeviceSequence,
               _0RL_CF_mDeviceSequence_marshal_fn,
               _0RL_CF_mDeviceSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DeviceSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDeviceSequence,
               _0RL_CF_mDeviceSequence_marshal_fn,
               _0RL_CF_mDeviceSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceSequence*& _sp)
{
  return _a >>= (const CF::DeviceSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDeviceSequence,
                    _0RL_CF_mDeviceSequence_unmarshal_fn,
                    _0RL_CF_mDeviceSequence_marshal_fn,
                    _0RL_CF_mDeviceSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::DeviceSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mAggregateDevice_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mAggregateDevice_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::AggregateDevice::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mAggregateDevice_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::AggregateDevice_ptr _o)
{
  CF::AggregateDevice_ptr _no = CF::AggregateDevice::_duplicate(_o);
  _a.PR_insert(CF::_tc_AggregateDevice,
               _0RL_CF_mAggregateDevice_marshal_fn,
               _0RL_CF_mAggregateDevice_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::AggregateDevice_ptr* _op)
{
  _a.PR_insert(CF::_tc_AggregateDevice,
               _0RL_CF_mAggregateDevice_marshal_fn,
               _0RL_CF_mAggregateDevice_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::AggregateDevice::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::AggregateDevice_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_AggregateDevice,
                    _0RL_CF_mAggregateDevice_unmarshal_fn,
                    _0RL_CF_mAggregateDevice_marshal_fn,
                    _0RL_CF_mAggregateDevice_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::AggregateDevice_ptr)_r->_ptrToObjRef(CF::AggregateDevice::_PD_repoId);
    else
      _o = CF::AggregateDevice::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mFileSystem_mUnknownFileSystemProperties_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::FileSystem::UnknownFileSystemProperties* _p = (const CF::FileSystem::UnknownFileSystemProperties*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileSystem_mUnknownFileSystemProperties_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileSystem::UnknownFileSystemProperties* _p = new CF::FileSystem::UnknownFileSystemProperties;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileSystem_mUnknownFileSystemProperties_destructor_fn(void* _v)
{
  CF::FileSystem::UnknownFileSystemProperties* _p = (CF::FileSystem::UnknownFileSystemProperties*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties& _s)
{
  CF::FileSystem::UnknownFileSystemProperties* _p = new CF::FileSystem::UnknownFileSystemProperties(_s);
  _a.PR_insert(_0RL_tc_CF_mFileSystem_mUnknownFileSystemProperties,
               _0RL_CF_mFileSystem_mUnknownFileSystemProperties_marshal_fn,
               _0RL_CF_mFileSystem_mUnknownFileSystemProperties_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileSystem_mUnknownFileSystemProperties,
               _0RL_CF_mFileSystem_mUnknownFileSystemProperties_marshal_fn,
               _0RL_CF_mFileSystem_mUnknownFileSystemProperties_destructor_fn,
               (CF::FileSystem::UnknownFileSystemProperties*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileSystem_mUnknownFileSystemProperties,
                    _0RL_CF_mFileSystem_mUnknownFileSystemProperties_unmarshal_fn,
                    _0RL_CF_mFileSystem_mUnknownFileSystemProperties_marshal_fn,
                    _0RL_CF_mFileSystem_mUnknownFileSystemProperties_destructor_fn,
                    _v)) {
    _sp = (const CF::FileSystem::UnknownFileSystemProperties*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mFileSystem_mUnknownFileSystemProperties(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::FileSystem::UnknownFileSystemProperties & _ex = (const CF::FileSystem::UnknownFileSystemProperties &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mFileSystem_mUnknownFileSystemProperties (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::FileSystem::UnknownFileSystemProperties* _ex = (const CF::FileSystem::UnknownFileSystemProperties*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mFileSystem_mUnknownFileSystemProperties {
public:
  _0RL_insertToAny_Singleton__cCF_mFileSystem_mUnknownFileSystemProperties() {
    CF::FileSystem::UnknownFileSystemProperties::insertToAnyFn = _0RL_insertToAny__cCF_mFileSystem_mUnknownFileSystemProperties;
    CF::FileSystem::UnknownFileSystemProperties::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mFileSystem_mUnknownFileSystemProperties;
  }
};
static _0RL_insertToAny_Singleton__cCF_mFileSystem_mUnknownFileSystemProperties _0RL_insertToAny_Singleton__cCF_mFileSystem_mUnknownFileSystemProperties_;

static void _0RL_CF_mFileSystem_mFileType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::FileSystem::FileType* _p = (CF::FileSystem::FileType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileSystem_mFileType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileSystem::FileType* _p = (CF::FileSystem::FileType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileType _s)
{
  _a.PR_insert(_0RL_tc_CF_mFileSystem_mFileType,
               _0RL_CF_mFileSystem_mFileType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileType& _s)
{
  return _a.PR_extract(_0RL_tc_CF_mFileSystem_mFileType,
                       _0RL_CF_mFileSystem_mFileType_unmarshal_fn,
                       &_s);
}

static void _0RL_CF_mFileSystem_mFileInformationType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::FileSystem::FileInformationType* _p = (CF::FileSystem::FileInformationType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileSystem_mFileInformationType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileSystem::FileInformationType* _p = new CF::FileSystem::FileInformationType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileSystem_mFileInformationType_destructor_fn(void* _v)
{
  CF::FileSystem::FileInformationType* _p = (CF::FileSystem::FileInformationType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileSystem::FileInformationType& _s)
{
  CF::FileSystem::FileInformationType* _p = new CF::FileSystem::FileInformationType(_s);
  _a.PR_insert(_0RL_tc_CF_mFileSystem_mFileInformationType,
               _0RL_CF_mFileSystem_mFileInformationType_marshal_fn,
               _0RL_CF_mFileSystem_mFileInformationType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileInformationType* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileSystem_mFileInformationType,
               _0RL_CF_mFileSystem_mFileInformationType_marshal_fn,
               _0RL_CF_mFileSystem_mFileInformationType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileInformationType*& _sp)
{
  return _a >>= (const CF::FileSystem::FileInformationType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::FileInformationType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileSystem_mFileInformationType,
                    _0RL_CF_mFileSystem_mFileInformationType_unmarshal_fn,
                    _0RL_CF_mFileSystem_mFileInformationType_marshal_fn,
                    _0RL_CF_mFileSystem_mFileInformationType_destructor_fn,
                    _v)) {
    _sp = (const CF::FileSystem::FileInformationType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mFileSystem_mFileInformationSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::FileSystem::FileInformationSequence* _p = (CF::FileSystem::FileInformationSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileSystem_mFileInformationSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileSystem::FileInformationSequence* _p = new CF::FileSystem::FileInformationSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileSystem_mFileInformationSequence_destructor_fn(void* _v)
{
  CF::FileSystem::FileInformationSequence* _p = (CF::FileSystem::FileInformationSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileSystem::FileInformationSequence& _s)
{
  CF::FileSystem::FileInformationSequence* _p = new CF::FileSystem::FileInformationSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mFileSystem_mFileInformationSequence,
               _0RL_CF_mFileSystem_mFileInformationSequence_marshal_fn,
               _0RL_CF_mFileSystem_mFileInformationSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileInformationSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileSystem_mFileInformationSequence,
               _0RL_CF_mFileSystem_mFileInformationSequence_marshal_fn,
               _0RL_CF_mFileSystem_mFileInformationSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileInformationSequence*& _sp)
{
  return _a >>= (const CF::FileSystem::FileInformationSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::FileInformationSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileSystem_mFileInformationSequence,
                    _0RL_CF_mFileSystem_mFileInformationSequence_unmarshal_fn,
                    _0RL_CF_mFileSystem_mFileInformationSequence_marshal_fn,
                    _0RL_CF_mFileSystem_mFileInformationSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::FileSystem::FileInformationSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mFileSystem_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mFileSystem_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::FileSystem::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mFileSystem_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::FileSystem_ptr _o)
{
  CF::FileSystem_ptr _no = CF::FileSystem::_duplicate(_o);
  _a.PR_insert(CF::_tc_FileSystem,
               _0RL_CF_mFileSystem_marshal_fn,
               _0RL_CF_mFileSystem_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::FileSystem_ptr* _op)
{
  _a.PR_insert(CF::_tc_FileSystem,
               _0RL_CF_mFileSystem_marshal_fn,
               _0RL_CF_mFileSystem_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::FileSystem::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_FileSystem,
                    _0RL_CF_mFileSystem_unmarshal_fn,
                    _0RL_CF_mFileSystem_marshal_fn,
                    _0RL_CF_mFileSystem_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::FileSystem_ptr)_r->_ptrToObjRef(CF::FileSystem::_PD_repoId);
    else
      _o = CF::FileSystem::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mFile_mIOException_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::File::IOException* _p = (const CF::File::IOException*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFile_mIOException_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::File::IOException* _p = new CF::File::IOException;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFile_mIOException_destructor_fn(void* _v)
{
  CF::File::IOException* _p = (CF::File::IOException*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::File::IOException& _s)
{
  CF::File::IOException* _p = new CF::File::IOException(_s);
  _a.PR_insert(_0RL_tc_CF_mFile_mIOException,
               _0RL_CF_mFile_mIOException_marshal_fn,
               _0RL_CF_mFile_mIOException_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::File::IOException* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFile_mIOException,
               _0RL_CF_mFile_mIOException_marshal_fn,
               _0RL_CF_mFile_mIOException_destructor_fn,
               (CF::File::IOException*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::File::IOException*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFile_mIOException,
                    _0RL_CF_mFile_mIOException_unmarshal_fn,
                    _0RL_CF_mFile_mIOException_marshal_fn,
                    _0RL_CF_mFile_mIOException_destructor_fn,
                    _v)) {
    _sp = (const CF::File::IOException*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mFile_mIOException(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::File::IOException & _ex = (const CF::File::IOException &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mFile_mIOException (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::File::IOException* _ex = (const CF::File::IOException*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mFile_mIOException {
public:
  _0RL_insertToAny_Singleton__cCF_mFile_mIOException() {
    CF::File::IOException::insertToAnyFn = _0RL_insertToAny__cCF_mFile_mIOException;
    CF::File::IOException::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mFile_mIOException;
  }
};
static _0RL_insertToAny_Singleton__cCF_mFile_mIOException _0RL_insertToAny_Singleton__cCF_mFile_mIOException_;


static void _0RL_CF_mFile_mInvalidFilePointer_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::File::InvalidFilePointer* _p = (const CF::File::InvalidFilePointer*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFile_mInvalidFilePointer_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::File::InvalidFilePointer* _p = new CF::File::InvalidFilePointer;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFile_mInvalidFilePointer_destructor_fn(void* _v)
{
  CF::File::InvalidFilePointer* _p = (CF::File::InvalidFilePointer*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::File::InvalidFilePointer& _s)
{
  CF::File::InvalidFilePointer* _p = new CF::File::InvalidFilePointer(_s);
  _a.PR_insert(_0RL_tc_CF_mFile_mInvalidFilePointer,
               _0RL_CF_mFile_mInvalidFilePointer_marshal_fn,
               _0RL_CF_mFile_mInvalidFilePointer_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::File::InvalidFilePointer* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFile_mInvalidFilePointer,
               _0RL_CF_mFile_mInvalidFilePointer_marshal_fn,
               _0RL_CF_mFile_mInvalidFilePointer_destructor_fn,
               (CF::File::InvalidFilePointer*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::File::InvalidFilePointer*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFile_mInvalidFilePointer,
                    _0RL_CF_mFile_mInvalidFilePointer_unmarshal_fn,
                    _0RL_CF_mFile_mInvalidFilePointer_marshal_fn,
                    _0RL_CF_mFile_mInvalidFilePointer_destructor_fn,
                    _v)) {
    _sp = (const CF::File::InvalidFilePointer*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mFile_mInvalidFilePointer(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::File::InvalidFilePointer & _ex = (const CF::File::InvalidFilePointer &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mFile_mInvalidFilePointer (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::File::InvalidFilePointer* _ex = (const CF::File::InvalidFilePointer*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mFile_mInvalidFilePointer {
public:
  _0RL_insertToAny_Singleton__cCF_mFile_mInvalidFilePointer() {
    CF::File::InvalidFilePointer::insertToAnyFn = _0RL_insertToAny__cCF_mFile_mInvalidFilePointer;
    CF::File::InvalidFilePointer::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mFile_mInvalidFilePointer;
  }
};
static _0RL_insertToAny_Singleton__cCF_mFile_mInvalidFilePointer _0RL_insertToAny_Singleton__cCF_mFile_mInvalidFilePointer_;

static void _0RL_CF_mFile_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mFile_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::File::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mFile_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::File_ptr _o)
{
  CF::File_ptr _no = CF::File::_duplicate(_o);
  _a.PR_insert(CF::_tc_File,
               _0RL_CF_mFile_marshal_fn,
               _0RL_CF_mFile_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::File_ptr* _op)
{
  _a.PR_insert(CF::_tc_File,
               _0RL_CF_mFile_marshal_fn,
               _0RL_CF_mFile_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::File::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::File_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_File,
                    _0RL_CF_mFile_unmarshal_fn,
                    _0RL_CF_mFile_marshal_fn,
                    _0RL_CF_mFile_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::File_ptr)_r->_ptrToObjRef(CF::File::_PD_repoId);
    else
      _o = CF::File::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mResourceFactory_mInvalidResourceId_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ResourceFactory::InvalidResourceId* _p = (const CF::ResourceFactory::InvalidResourceId*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mResourceFactory_mInvalidResourceId_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ResourceFactory::InvalidResourceId* _p = new CF::ResourceFactory::InvalidResourceId;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mResourceFactory_mInvalidResourceId_destructor_fn(void* _v)
{
  CF::ResourceFactory::InvalidResourceId* _p = (CF::ResourceFactory::InvalidResourceId*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId& _s)
{
  CF::ResourceFactory::InvalidResourceId* _p = new CF::ResourceFactory::InvalidResourceId(_s);
  _a.PR_insert(_0RL_tc_CF_mResourceFactory_mInvalidResourceId,
               _0RL_CF_mResourceFactory_mInvalidResourceId_marshal_fn,
               _0RL_CF_mResourceFactory_mInvalidResourceId_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mResourceFactory_mInvalidResourceId,
               _0RL_CF_mResourceFactory_mInvalidResourceId_marshal_fn,
               _0RL_CF_mResourceFactory_mInvalidResourceId_destructor_fn,
               (CF::ResourceFactory::InvalidResourceId*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mResourceFactory_mInvalidResourceId,
                    _0RL_CF_mResourceFactory_mInvalidResourceId_unmarshal_fn,
                    _0RL_CF_mResourceFactory_mInvalidResourceId_marshal_fn,
                    _0RL_CF_mResourceFactory_mInvalidResourceId_destructor_fn,
                    _v)) {
    _sp = (const CF::ResourceFactory::InvalidResourceId*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mResourceFactory_mInvalidResourceId(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ResourceFactory::InvalidResourceId & _ex = (const CF::ResourceFactory::InvalidResourceId &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mResourceFactory_mInvalidResourceId (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ResourceFactory::InvalidResourceId* _ex = (const CF::ResourceFactory::InvalidResourceId*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mResourceFactory_mInvalidResourceId {
public:
  _0RL_insertToAny_Singleton__cCF_mResourceFactory_mInvalidResourceId() {
    CF::ResourceFactory::InvalidResourceId::insertToAnyFn = _0RL_insertToAny__cCF_mResourceFactory_mInvalidResourceId;
    CF::ResourceFactory::InvalidResourceId::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mResourceFactory_mInvalidResourceId;
  }
};
static _0RL_insertToAny_Singleton__cCF_mResourceFactory_mInvalidResourceId _0RL_insertToAny_Singleton__cCF_mResourceFactory_mInvalidResourceId_;


static void _0RL_CF_mResourceFactory_mShutdownFailure_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ResourceFactory::ShutdownFailure* _p = (const CF::ResourceFactory::ShutdownFailure*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mResourceFactory_mShutdownFailure_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ResourceFactory::ShutdownFailure* _p = new CF::ResourceFactory::ShutdownFailure;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mResourceFactory_mShutdownFailure_destructor_fn(void* _v)
{
  CF::ResourceFactory::ShutdownFailure* _p = (CF::ResourceFactory::ShutdownFailure*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure& _s)
{
  CF::ResourceFactory::ShutdownFailure* _p = new CF::ResourceFactory::ShutdownFailure(_s);
  _a.PR_insert(_0RL_tc_CF_mResourceFactory_mShutdownFailure,
               _0RL_CF_mResourceFactory_mShutdownFailure_marshal_fn,
               _0RL_CF_mResourceFactory_mShutdownFailure_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mResourceFactory_mShutdownFailure,
               _0RL_CF_mResourceFactory_mShutdownFailure_marshal_fn,
               _0RL_CF_mResourceFactory_mShutdownFailure_destructor_fn,
               (CF::ResourceFactory::ShutdownFailure*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mResourceFactory_mShutdownFailure,
                    _0RL_CF_mResourceFactory_mShutdownFailure_unmarshal_fn,
                    _0RL_CF_mResourceFactory_mShutdownFailure_marshal_fn,
                    _0RL_CF_mResourceFactory_mShutdownFailure_destructor_fn,
                    _v)) {
    _sp = (const CF::ResourceFactory::ShutdownFailure*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mResourceFactory_mShutdownFailure(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ResourceFactory::ShutdownFailure & _ex = (const CF::ResourceFactory::ShutdownFailure &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mResourceFactory_mShutdownFailure (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ResourceFactory::ShutdownFailure* _ex = (const CF::ResourceFactory::ShutdownFailure*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mResourceFactory_mShutdownFailure {
public:
  _0RL_insertToAny_Singleton__cCF_mResourceFactory_mShutdownFailure() {
    CF::ResourceFactory::ShutdownFailure::insertToAnyFn = _0RL_insertToAny__cCF_mResourceFactory_mShutdownFailure;
    CF::ResourceFactory::ShutdownFailure::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mResourceFactory_mShutdownFailure;
  }
};
static _0RL_insertToAny_Singleton__cCF_mResourceFactory_mShutdownFailure _0RL_insertToAny_Singleton__cCF_mResourceFactory_mShutdownFailure_;


static void _0RL_CF_mResourceFactory_mCreateResourceFailure_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ResourceFactory::CreateResourceFailure* _p = (const CF::ResourceFactory::CreateResourceFailure*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mResourceFactory_mCreateResourceFailure_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ResourceFactory::CreateResourceFailure* _p = new CF::ResourceFactory::CreateResourceFailure;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mResourceFactory_mCreateResourceFailure_destructor_fn(void* _v)
{
  CF::ResourceFactory::CreateResourceFailure* _p = (CF::ResourceFactory::CreateResourceFailure*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure& _s)
{
  CF::ResourceFactory::CreateResourceFailure* _p = new CF::ResourceFactory::CreateResourceFailure(_s);
  _a.PR_insert(_0RL_tc_CF_mResourceFactory_mCreateResourceFailure,
               _0RL_CF_mResourceFactory_mCreateResourceFailure_marshal_fn,
               _0RL_CF_mResourceFactory_mCreateResourceFailure_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mResourceFactory_mCreateResourceFailure,
               _0RL_CF_mResourceFactory_mCreateResourceFailure_marshal_fn,
               _0RL_CF_mResourceFactory_mCreateResourceFailure_destructor_fn,
               (CF::ResourceFactory::CreateResourceFailure*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mResourceFactory_mCreateResourceFailure,
                    _0RL_CF_mResourceFactory_mCreateResourceFailure_unmarshal_fn,
                    _0RL_CF_mResourceFactory_mCreateResourceFailure_marshal_fn,
                    _0RL_CF_mResourceFactory_mCreateResourceFailure_destructor_fn,
                    _v)) {
    _sp = (const CF::ResourceFactory::CreateResourceFailure*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mResourceFactory_mCreateResourceFailure(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ResourceFactory::CreateResourceFailure & _ex = (const CF::ResourceFactory::CreateResourceFailure &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mResourceFactory_mCreateResourceFailure (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ResourceFactory::CreateResourceFailure* _ex = (const CF::ResourceFactory::CreateResourceFailure*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mResourceFactory_mCreateResourceFailure {
public:
  _0RL_insertToAny_Singleton__cCF_mResourceFactory_mCreateResourceFailure() {
    CF::ResourceFactory::CreateResourceFailure::insertToAnyFn = _0RL_insertToAny__cCF_mResourceFactory_mCreateResourceFailure;
    CF::ResourceFactory::CreateResourceFailure::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mResourceFactory_mCreateResourceFailure;
  }
};
static _0RL_insertToAny_Singleton__cCF_mResourceFactory_mCreateResourceFailure _0RL_insertToAny_Singleton__cCF_mResourceFactory_mCreateResourceFailure_;

static void _0RL_CF_mResourceFactory_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mResourceFactory_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::ResourceFactory::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mResourceFactory_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::ResourceFactory_ptr _o)
{
  CF::ResourceFactory_ptr _no = CF::ResourceFactory::_duplicate(_o);
  _a.PR_insert(CF::_tc_ResourceFactory,
               _0RL_CF_mResourceFactory_marshal_fn,
               _0RL_CF_mResourceFactory_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::ResourceFactory_ptr* _op)
{
  _a.PR_insert(CF::_tc_ResourceFactory,
               _0RL_CF_mResourceFactory_marshal_fn,
               _0RL_CF_mResourceFactory_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::ResourceFactory::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::ResourceFactory_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_ResourceFactory,
                    _0RL_CF_mResourceFactory_unmarshal_fn,
                    _0RL_CF_mResourceFactory_marshal_fn,
                    _0RL_CF_mResourceFactory_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::ResourceFactory_ptr)_r->_ptrToObjRef(CF::ResourceFactory::_PD_repoId);
    else
      _o = CF::ResourceFactory::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CF_mFileManager_mMountType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::FileManager::MountType* _p = (CF::FileManager::MountType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileManager_mMountType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileManager::MountType* _p = new CF::FileManager::MountType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileManager_mMountType_destructor_fn(void* _v)
{
  CF::FileManager::MountType* _p = (CF::FileManager::MountType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountType& _s)
{
  CF::FileManager::MountType* _p = new CF::FileManager::MountType(_s);
  _a.PR_insert(_0RL_tc_CF_mFileManager_mMountType,
               _0RL_CF_mFileManager_mMountType_marshal_fn,
               _0RL_CF_mFileManager_mMountType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::FileManager::MountType* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileManager_mMountType,
               _0RL_CF_mFileManager_mMountType_marshal_fn,
               _0RL_CF_mFileManager_mMountType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager::MountType*& _sp)
{
  return _a >>= (const CF::FileManager::MountType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileManager_mMountType,
                    _0RL_CF_mFileManager_mMountType_unmarshal_fn,
                    _0RL_CF_mFileManager_mMountType_marshal_fn,
                    _0RL_CF_mFileManager_mMountType_destructor_fn,
                    _v)) {
    _sp = (const CF::FileManager::MountType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mFileManager_mMountSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::FileManager::MountSequence* _p = (CF::FileManager::MountSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileManager_mMountSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileManager::MountSequence* _p = new CF::FileManager::MountSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileManager_mMountSequence_destructor_fn(void* _v)
{
  CF::FileManager::MountSequence* _p = (CF::FileManager::MountSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountSequence& _s)
{
  CF::FileManager::MountSequence* _p = new CF::FileManager::MountSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mFileManager_mMountSequence,
               _0RL_CF_mFileManager_mMountSequence_marshal_fn,
               _0RL_CF_mFileManager_mMountSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::FileManager::MountSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileManager_mMountSequence,
               _0RL_CF_mFileManager_mMountSequence_marshal_fn,
               _0RL_CF_mFileManager_mMountSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager::MountSequence*& _sp)
{
  return _a >>= (const CF::FileManager::MountSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileManager_mMountSequence,
                    _0RL_CF_mFileManager_mMountSequence_unmarshal_fn,
                    _0RL_CF_mFileManager_mMountSequence_marshal_fn,
                    _0RL_CF_mFileManager_mMountSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::FileManager::MountSequence*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_CF_mFileManager_mNonExistentMount_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::FileManager::NonExistentMount* _p = (const CF::FileManager::NonExistentMount*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileManager_mNonExistentMount_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileManager::NonExistentMount* _p = new CF::FileManager::NonExistentMount;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileManager_mNonExistentMount_destructor_fn(void* _v)
{
  CF::FileManager::NonExistentMount* _p = (CF::FileManager::NonExistentMount*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileManager::NonExistentMount& _s)
{
  CF::FileManager::NonExistentMount* _p = new CF::FileManager::NonExistentMount(_s);
  _a.PR_insert(_0RL_tc_CF_mFileManager_mNonExistentMount,
               _0RL_CF_mFileManager_mNonExistentMount_marshal_fn,
               _0RL_CF_mFileManager_mNonExistentMount_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::FileManager::NonExistentMount* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileManager_mNonExistentMount,
               _0RL_CF_mFileManager_mNonExistentMount_marshal_fn,
               _0RL_CF_mFileManager_mNonExistentMount_destructor_fn,
               (CF::FileManager::NonExistentMount*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::NonExistentMount*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileManager_mNonExistentMount,
                    _0RL_CF_mFileManager_mNonExistentMount_unmarshal_fn,
                    _0RL_CF_mFileManager_mNonExistentMount_marshal_fn,
                    _0RL_CF_mFileManager_mNonExistentMount_destructor_fn,
                    _v)) {
    _sp = (const CF::FileManager::NonExistentMount*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mFileManager_mNonExistentMount(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::FileManager::NonExistentMount & _ex = (const CF::FileManager::NonExistentMount &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mFileManager_mNonExistentMount (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::FileManager::NonExistentMount* _ex = (const CF::FileManager::NonExistentMount*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mFileManager_mNonExistentMount {
public:
  _0RL_insertToAny_Singleton__cCF_mFileManager_mNonExistentMount() {
    CF::FileManager::NonExistentMount::insertToAnyFn = _0RL_insertToAny__cCF_mFileManager_mNonExistentMount;
    CF::FileManager::NonExistentMount::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mFileManager_mNonExistentMount;
  }
};
static _0RL_insertToAny_Singleton__cCF_mFileManager_mNonExistentMount _0RL_insertToAny_Singleton__cCF_mFileManager_mNonExistentMount_;


static void _0RL_CF_mFileManager_mInvalidFileSystem_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::FileManager::InvalidFileSystem* _p = (const CF::FileManager::InvalidFileSystem*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileManager_mInvalidFileSystem_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileManager::InvalidFileSystem* _p = new CF::FileManager::InvalidFileSystem;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileManager_mInvalidFileSystem_destructor_fn(void* _v)
{
  CF::FileManager::InvalidFileSystem* _p = (CF::FileManager::InvalidFileSystem*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem& _s)
{
  CF::FileManager::InvalidFileSystem* _p = new CF::FileManager::InvalidFileSystem(_s);
  _a.PR_insert(_0RL_tc_CF_mFileManager_mInvalidFileSystem,
               _0RL_CF_mFileManager_mInvalidFileSystem_marshal_fn,
               _0RL_CF_mFileManager_mInvalidFileSystem_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileManager_mInvalidFileSystem,
               _0RL_CF_mFileManager_mInvalidFileSystem_marshal_fn,
               _0RL_CF_mFileManager_mInvalidFileSystem_destructor_fn,
               (CF::FileManager::InvalidFileSystem*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileManager_mInvalidFileSystem,
                    _0RL_CF_mFileManager_mInvalidFileSystem_unmarshal_fn,
                    _0RL_CF_mFileManager_mInvalidFileSystem_marshal_fn,
                    _0RL_CF_mFileManager_mInvalidFileSystem_destructor_fn,
                    _v)) {
    _sp = (const CF::FileManager::InvalidFileSystem*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mFileManager_mInvalidFileSystem(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::FileManager::InvalidFileSystem & _ex = (const CF::FileManager::InvalidFileSystem &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mFileManager_mInvalidFileSystem (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::FileManager::InvalidFileSystem* _ex = (const CF::FileManager::InvalidFileSystem*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mFileManager_mInvalidFileSystem {
public:
  _0RL_insertToAny_Singleton__cCF_mFileManager_mInvalidFileSystem() {
    CF::FileManager::InvalidFileSystem::insertToAnyFn = _0RL_insertToAny__cCF_mFileManager_mInvalidFileSystem;
    CF::FileManager::InvalidFileSystem::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mFileManager_mInvalidFileSystem;
  }
};
static _0RL_insertToAny_Singleton__cCF_mFileManager_mInvalidFileSystem _0RL_insertToAny_Singleton__cCF_mFileManager_mInvalidFileSystem_;


static void _0RL_CF_mFileManager_mMountPointAlreadyExists_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::FileManager::MountPointAlreadyExists* _p = (const CF::FileManager::MountPointAlreadyExists*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mFileManager_mMountPointAlreadyExists_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::FileManager::MountPointAlreadyExists* _p = new CF::FileManager::MountPointAlreadyExists;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mFileManager_mMountPointAlreadyExists_destructor_fn(void* _v)
{
  CF::FileManager::MountPointAlreadyExists* _p = (CF::FileManager::MountPointAlreadyExists*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists& _s)
{
  CF::FileManager::MountPointAlreadyExists* _p = new CF::FileManager::MountPointAlreadyExists(_s);
  _a.PR_insert(_0RL_tc_CF_mFileManager_mMountPointAlreadyExists,
               _0RL_CF_mFileManager_mMountPointAlreadyExists_marshal_fn,
               _0RL_CF_mFileManager_mMountPointAlreadyExists_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mFileManager_mMountPointAlreadyExists,
               _0RL_CF_mFileManager_mMountPointAlreadyExists_marshal_fn,
               _0RL_CF_mFileManager_mMountPointAlreadyExists_destructor_fn,
               (CF::FileManager::MountPointAlreadyExists*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mFileManager_mMountPointAlreadyExists,
                    _0RL_CF_mFileManager_mMountPointAlreadyExists_unmarshal_fn,
                    _0RL_CF_mFileManager_mMountPointAlreadyExists_marshal_fn,
                    _0RL_CF_mFileManager_mMountPointAlreadyExists_destructor_fn,
                    _v)) {
    _sp = (const CF::FileManager::MountPointAlreadyExists*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mFileManager_mMountPointAlreadyExists(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::FileManager::MountPointAlreadyExists & _ex = (const CF::FileManager::MountPointAlreadyExists &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mFileManager_mMountPointAlreadyExists (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::FileManager::MountPointAlreadyExists* _ex = (const CF::FileManager::MountPointAlreadyExists*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mFileManager_mMountPointAlreadyExists {
public:
  _0RL_insertToAny_Singleton__cCF_mFileManager_mMountPointAlreadyExists() {
    CF::FileManager::MountPointAlreadyExists::insertToAnyFn = _0RL_insertToAny__cCF_mFileManager_mMountPointAlreadyExists;
    CF::FileManager::MountPointAlreadyExists::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mFileManager_mMountPointAlreadyExists;
  }
};
static _0RL_insertToAny_Singleton__cCF_mFileManager_mMountPointAlreadyExists _0RL_insertToAny_Singleton__cCF_mFileManager_mMountPointAlreadyExists_;

static void _0RL_CF_mFileManager_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mFileManager_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::FileManager::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mFileManager_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::FileManager_ptr _o)
{
  CF::FileManager_ptr _no = CF::FileManager::_duplicate(_o);
  _a.PR_insert(CF::_tc_FileManager,
               _0RL_CF_mFileManager_marshal_fn,
               _0RL_CF_mFileManager_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::FileManager_ptr* _op)
{
  _a.PR_insert(CF::_tc_FileManager,
               _0RL_CF_mFileManager_marshal_fn,
               _0RL_CF_mFileManager_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::FileManager::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_FileManager,
                    _0RL_CF_mFileManager_unmarshal_fn,
                    _0RL_CF_mFileManager_marshal_fn,
                    _0RL_CF_mFileManager_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::FileManager_ptr)_r->_ptrToObjRef(CF::FileManager::_PD_repoId);
    else
      _o = CF::FileManager::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mPort_mInvalidPort_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::Port::InvalidPort* _p = (const CF::Port::InvalidPort*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mPort_mInvalidPort_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Port::InvalidPort* _p = new CF::Port::InvalidPort;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mPort_mInvalidPort_destructor_fn(void* _v)
{
  CF::Port::InvalidPort* _p = (CF::Port::InvalidPort*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Port::InvalidPort& _s)
{
  CF::Port::InvalidPort* _p = new CF::Port::InvalidPort(_s);
  _a.PR_insert(_0RL_tc_CF_mPort_mInvalidPort,
               _0RL_CF_mPort_mInvalidPort_marshal_fn,
               _0RL_CF_mPort_mInvalidPort_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::Port::InvalidPort* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mPort_mInvalidPort,
               _0RL_CF_mPort_mInvalidPort_marshal_fn,
               _0RL_CF_mPort_mInvalidPort_destructor_fn,
               (CF::Port::InvalidPort*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Port::InvalidPort*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mPort_mInvalidPort,
                    _0RL_CF_mPort_mInvalidPort_unmarshal_fn,
                    _0RL_CF_mPort_mInvalidPort_marshal_fn,
                    _0RL_CF_mPort_mInvalidPort_destructor_fn,
                    _v)) {
    _sp = (const CF::Port::InvalidPort*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mPort_mInvalidPort(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::Port::InvalidPort & _ex = (const CF::Port::InvalidPort &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mPort_mInvalidPort (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::Port::InvalidPort* _ex = (const CF::Port::InvalidPort*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mPort_mInvalidPort {
public:
  _0RL_insertToAny_Singleton__cCF_mPort_mInvalidPort() {
    CF::Port::InvalidPort::insertToAnyFn = _0RL_insertToAny__cCF_mPort_mInvalidPort;
    CF::Port::InvalidPort::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mPort_mInvalidPort;
  }
};
static _0RL_insertToAny_Singleton__cCF_mPort_mInvalidPort _0RL_insertToAny_Singleton__cCF_mPort_mInvalidPort_;


static void _0RL_CF_mPort_mOccupiedPort_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::Port::OccupiedPort* _p = (const CF::Port::OccupiedPort*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mPort_mOccupiedPort_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Port::OccupiedPort* _p = new CF::Port::OccupiedPort;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mPort_mOccupiedPort_destructor_fn(void* _v)
{
  CF::Port::OccupiedPort* _p = (CF::Port::OccupiedPort*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Port::OccupiedPort& _s)
{
  CF::Port::OccupiedPort* _p = new CF::Port::OccupiedPort(_s);
  _a.PR_insert(_0RL_tc_CF_mPort_mOccupiedPort,
               _0RL_CF_mPort_mOccupiedPort_marshal_fn,
               _0RL_CF_mPort_mOccupiedPort_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::Port::OccupiedPort* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mPort_mOccupiedPort,
               _0RL_CF_mPort_mOccupiedPort_marshal_fn,
               _0RL_CF_mPort_mOccupiedPort_destructor_fn,
               (CF::Port::OccupiedPort*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Port::OccupiedPort*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mPort_mOccupiedPort,
                    _0RL_CF_mPort_mOccupiedPort_unmarshal_fn,
                    _0RL_CF_mPort_mOccupiedPort_marshal_fn,
                    _0RL_CF_mPort_mOccupiedPort_destructor_fn,
                    _v)) {
    _sp = (const CF::Port::OccupiedPort*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mPort_mOccupiedPort(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::Port::OccupiedPort & _ex = (const CF::Port::OccupiedPort &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mPort_mOccupiedPort (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::Port::OccupiedPort* _ex = (const CF::Port::OccupiedPort*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mPort_mOccupiedPort {
public:
  _0RL_insertToAny_Singleton__cCF_mPort_mOccupiedPort() {
    CF::Port::OccupiedPort::insertToAnyFn = _0RL_insertToAny__cCF_mPort_mOccupiedPort;
    CF::Port::OccupiedPort::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mPort_mOccupiedPort;
  }
};
static _0RL_insertToAny_Singleton__cCF_mPort_mOccupiedPort _0RL_insertToAny_Singleton__cCF_mPort_mOccupiedPort_;

static void _0RL_CF_mPort_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mPort_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::Port::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mPort_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::Port_ptr _o)
{
  CF::Port_ptr _no = CF::Port::_duplicate(_o);
  _a.PR_insert(CF::_tc_Port,
               _0RL_CF_mPort_marshal_fn,
               _0RL_CF_mPort_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::Port_ptr* _op)
{
  _a.PR_insert(CF::_tc_Port,
               _0RL_CF_mPort_marshal_fn,
               _0RL_CF_mPort_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::Port::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Port_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_Port,
                    _0RL_CF_mPort_unmarshal_fn,
                    _0RL_CF_mPort_marshal_fn,
                    _0RL_CF_mPort_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::Port_ptr)_r->_ptrToObjRef(CF::Port::_PD_repoId);
    else
      _o = CF::Port::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mLifeCycle_mInitializeError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::LifeCycle::InitializeError* _p = (const CF::LifeCycle::InitializeError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mLifeCycle_mInitializeError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::LifeCycle::InitializeError* _p = new CF::LifeCycle::InitializeError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mLifeCycle_mInitializeError_destructor_fn(void* _v)
{
  CF::LifeCycle::InitializeError* _p = (CF::LifeCycle::InitializeError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::InitializeError& _s)
{
  CF::LifeCycle::InitializeError* _p = new CF::LifeCycle::InitializeError(_s);
  _a.PR_insert(_0RL_tc_CF_mLifeCycle_mInitializeError,
               _0RL_CF_mLifeCycle_mInitializeError_marshal_fn,
               _0RL_CF_mLifeCycle_mInitializeError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::InitializeError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mLifeCycle_mInitializeError,
               _0RL_CF_mLifeCycle_mInitializeError_marshal_fn,
               _0RL_CF_mLifeCycle_mInitializeError_destructor_fn,
               (CF::LifeCycle::InitializeError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::LifeCycle::InitializeError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mLifeCycle_mInitializeError,
                    _0RL_CF_mLifeCycle_mInitializeError_unmarshal_fn,
                    _0RL_CF_mLifeCycle_mInitializeError_marshal_fn,
                    _0RL_CF_mLifeCycle_mInitializeError_destructor_fn,
                    _v)) {
    _sp = (const CF::LifeCycle::InitializeError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mLifeCycle_mInitializeError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::LifeCycle::InitializeError & _ex = (const CF::LifeCycle::InitializeError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mLifeCycle_mInitializeError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::LifeCycle::InitializeError* _ex = (const CF::LifeCycle::InitializeError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mLifeCycle_mInitializeError {
public:
  _0RL_insertToAny_Singleton__cCF_mLifeCycle_mInitializeError() {
    CF::LifeCycle::InitializeError::insertToAnyFn = _0RL_insertToAny__cCF_mLifeCycle_mInitializeError;
    CF::LifeCycle::InitializeError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mLifeCycle_mInitializeError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mLifeCycle_mInitializeError _0RL_insertToAny_Singleton__cCF_mLifeCycle_mInitializeError_;


static void _0RL_CF_mLifeCycle_mReleaseError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::LifeCycle::ReleaseError* _p = (const CF::LifeCycle::ReleaseError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mLifeCycle_mReleaseError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::LifeCycle::ReleaseError* _p = new CF::LifeCycle::ReleaseError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mLifeCycle_mReleaseError_destructor_fn(void* _v)
{
  CF::LifeCycle::ReleaseError* _p = (CF::LifeCycle::ReleaseError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::ReleaseError& _s)
{
  CF::LifeCycle::ReleaseError* _p = new CF::LifeCycle::ReleaseError(_s);
  _a.PR_insert(_0RL_tc_CF_mLifeCycle_mReleaseError,
               _0RL_CF_mLifeCycle_mReleaseError_marshal_fn,
               _0RL_CF_mLifeCycle_mReleaseError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::ReleaseError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mLifeCycle_mReleaseError,
               _0RL_CF_mLifeCycle_mReleaseError_marshal_fn,
               _0RL_CF_mLifeCycle_mReleaseError_destructor_fn,
               (CF::LifeCycle::ReleaseError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::LifeCycle::ReleaseError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mLifeCycle_mReleaseError,
                    _0RL_CF_mLifeCycle_mReleaseError_unmarshal_fn,
                    _0RL_CF_mLifeCycle_mReleaseError_marshal_fn,
                    _0RL_CF_mLifeCycle_mReleaseError_destructor_fn,
                    _v)) {
    _sp = (const CF::LifeCycle::ReleaseError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mLifeCycle_mReleaseError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::LifeCycle::ReleaseError & _ex = (const CF::LifeCycle::ReleaseError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mLifeCycle_mReleaseError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::LifeCycle::ReleaseError* _ex = (const CF::LifeCycle::ReleaseError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mLifeCycle_mReleaseError {
public:
  _0RL_insertToAny_Singleton__cCF_mLifeCycle_mReleaseError() {
    CF::LifeCycle::ReleaseError::insertToAnyFn = _0RL_insertToAny__cCF_mLifeCycle_mReleaseError;
    CF::LifeCycle::ReleaseError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mLifeCycle_mReleaseError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mLifeCycle_mReleaseError _0RL_insertToAny_Singleton__cCF_mLifeCycle_mReleaseError_;

static void _0RL_CF_mLifeCycle_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mLifeCycle_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::LifeCycle::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mLifeCycle_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::LifeCycle_ptr _o)
{
  CF::LifeCycle_ptr _no = CF::LifeCycle::_duplicate(_o);
  _a.PR_insert(CF::_tc_LifeCycle,
               _0RL_CF_mLifeCycle_marshal_fn,
               _0RL_CF_mLifeCycle_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::LifeCycle_ptr* _op)
{
  _a.PR_insert(CF::_tc_LifeCycle,
               _0RL_CF_mLifeCycle_marshal_fn,
               _0RL_CF_mLifeCycle_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::LifeCycle::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::LifeCycle_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_LifeCycle,
                    _0RL_CF_mLifeCycle_unmarshal_fn,
                    _0RL_CF_mLifeCycle_marshal_fn,
                    _0RL_CF_mLifeCycle_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::LifeCycle_ptr)_r->_ptrToObjRef(CF::LifeCycle::_PD_repoId);
    else
      _o = CF::LifeCycle::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mTestableObject_mUnknownTest_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::TestableObject::UnknownTest* _p = (const CF::TestableObject::UnknownTest*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mTestableObject_mUnknownTest_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::TestableObject::UnknownTest* _p = new CF::TestableObject::UnknownTest;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mTestableObject_mUnknownTest_destructor_fn(void* _v)
{
  CF::TestableObject::UnknownTest* _p = (CF::TestableObject::UnknownTest*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::TestableObject::UnknownTest& _s)
{
  CF::TestableObject::UnknownTest* _p = new CF::TestableObject::UnknownTest(_s);
  _a.PR_insert(_0RL_tc_CF_mTestableObject_mUnknownTest,
               _0RL_CF_mTestableObject_mUnknownTest_marshal_fn,
               _0RL_CF_mTestableObject_mUnknownTest_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::TestableObject::UnknownTest* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mTestableObject_mUnknownTest,
               _0RL_CF_mTestableObject_mUnknownTest_marshal_fn,
               _0RL_CF_mTestableObject_mUnknownTest_destructor_fn,
               (CF::TestableObject::UnknownTest*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::TestableObject::UnknownTest*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mTestableObject_mUnknownTest,
                    _0RL_CF_mTestableObject_mUnknownTest_unmarshal_fn,
                    _0RL_CF_mTestableObject_mUnknownTest_marshal_fn,
                    _0RL_CF_mTestableObject_mUnknownTest_destructor_fn,
                    _v)) {
    _sp = (const CF::TestableObject::UnknownTest*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mTestableObject_mUnknownTest(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::TestableObject::UnknownTest & _ex = (const CF::TestableObject::UnknownTest &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mTestableObject_mUnknownTest (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::TestableObject::UnknownTest* _ex = (const CF::TestableObject::UnknownTest*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mTestableObject_mUnknownTest {
public:
  _0RL_insertToAny_Singleton__cCF_mTestableObject_mUnknownTest() {
    CF::TestableObject::UnknownTest::insertToAnyFn = _0RL_insertToAny__cCF_mTestableObject_mUnknownTest;
    CF::TestableObject::UnknownTest::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mTestableObject_mUnknownTest;
  }
};
static _0RL_insertToAny_Singleton__cCF_mTestableObject_mUnknownTest _0RL_insertToAny_Singleton__cCF_mTestableObject_mUnknownTest_;

static void _0RL_CF_mTestableObject_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mTestableObject_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::TestableObject::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mTestableObject_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::TestableObject_ptr _o)
{
  CF::TestableObject_ptr _no = CF::TestableObject::_duplicate(_o);
  _a.PR_insert(CF::_tc_TestableObject,
               _0RL_CF_mTestableObject_marshal_fn,
               _0RL_CF_mTestableObject_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::TestableObject_ptr* _op)
{
  _a.PR_insert(CF::_tc_TestableObject,
               _0RL_CF_mTestableObject_marshal_fn,
               _0RL_CF_mTestableObject_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::TestableObject::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::TestableObject_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_TestableObject,
                    _0RL_CF_mTestableObject_unmarshal_fn,
                    _0RL_CF_mTestableObject_marshal_fn,
                    _0RL_CF_mTestableObject_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::TestableObject_ptr)_r->_ptrToObjRef(CF::TestableObject::_PD_repoId);
    else
      _o = CF::TestableObject::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mPropertySet_mInvalidConfiguration_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::PropertySet::InvalidConfiguration* _p = (const CF::PropertySet::InvalidConfiguration*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mPropertySet_mInvalidConfiguration_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::PropertySet::InvalidConfiguration* _p = new CF::PropertySet::InvalidConfiguration;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mPropertySet_mInvalidConfiguration_destructor_fn(void* _v)
{
  CF::PropertySet::InvalidConfiguration* _p = (CF::PropertySet::InvalidConfiguration*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration& _s)
{
  CF::PropertySet::InvalidConfiguration* _p = new CF::PropertySet::InvalidConfiguration(_s);
  _a.PR_insert(_0RL_tc_CF_mPropertySet_mInvalidConfiguration,
               _0RL_CF_mPropertySet_mInvalidConfiguration_marshal_fn,
               _0RL_CF_mPropertySet_mInvalidConfiguration_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mPropertySet_mInvalidConfiguration,
               _0RL_CF_mPropertySet_mInvalidConfiguration_marshal_fn,
               _0RL_CF_mPropertySet_mInvalidConfiguration_destructor_fn,
               (CF::PropertySet::InvalidConfiguration*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mPropertySet_mInvalidConfiguration,
                    _0RL_CF_mPropertySet_mInvalidConfiguration_unmarshal_fn,
                    _0RL_CF_mPropertySet_mInvalidConfiguration_marshal_fn,
                    _0RL_CF_mPropertySet_mInvalidConfiguration_destructor_fn,
                    _v)) {
    _sp = (const CF::PropertySet::InvalidConfiguration*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mPropertySet_mInvalidConfiguration(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::PropertySet::InvalidConfiguration & _ex = (const CF::PropertySet::InvalidConfiguration &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mPropertySet_mInvalidConfiguration (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::PropertySet::InvalidConfiguration* _ex = (const CF::PropertySet::InvalidConfiguration*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mPropertySet_mInvalidConfiguration {
public:
  _0RL_insertToAny_Singleton__cCF_mPropertySet_mInvalidConfiguration() {
    CF::PropertySet::InvalidConfiguration::insertToAnyFn = _0RL_insertToAny__cCF_mPropertySet_mInvalidConfiguration;
    CF::PropertySet::InvalidConfiguration::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mPropertySet_mInvalidConfiguration;
  }
};
static _0RL_insertToAny_Singleton__cCF_mPropertySet_mInvalidConfiguration _0RL_insertToAny_Singleton__cCF_mPropertySet_mInvalidConfiguration_;


static void _0RL_CF_mPropertySet_mPartialConfiguration_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::PropertySet::PartialConfiguration* _p = (const CF::PropertySet::PartialConfiguration*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mPropertySet_mPartialConfiguration_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::PropertySet::PartialConfiguration* _p = new CF::PropertySet::PartialConfiguration;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mPropertySet_mPartialConfiguration_destructor_fn(void* _v)
{
  CF::PropertySet::PartialConfiguration* _p = (CF::PropertySet::PartialConfiguration*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration& _s)
{
  CF::PropertySet::PartialConfiguration* _p = new CF::PropertySet::PartialConfiguration(_s);
  _a.PR_insert(_0RL_tc_CF_mPropertySet_mPartialConfiguration,
               _0RL_CF_mPropertySet_mPartialConfiguration_marshal_fn,
               _0RL_CF_mPropertySet_mPartialConfiguration_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mPropertySet_mPartialConfiguration,
               _0RL_CF_mPropertySet_mPartialConfiguration_marshal_fn,
               _0RL_CF_mPropertySet_mPartialConfiguration_destructor_fn,
               (CF::PropertySet::PartialConfiguration*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mPropertySet_mPartialConfiguration,
                    _0RL_CF_mPropertySet_mPartialConfiguration_unmarshal_fn,
                    _0RL_CF_mPropertySet_mPartialConfiguration_marshal_fn,
                    _0RL_CF_mPropertySet_mPartialConfiguration_destructor_fn,
                    _v)) {
    _sp = (const CF::PropertySet::PartialConfiguration*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mPropertySet_mPartialConfiguration(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::PropertySet::PartialConfiguration & _ex = (const CF::PropertySet::PartialConfiguration &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mPropertySet_mPartialConfiguration (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::PropertySet::PartialConfiguration* _ex = (const CF::PropertySet::PartialConfiguration*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mPropertySet_mPartialConfiguration {
public:
  _0RL_insertToAny_Singleton__cCF_mPropertySet_mPartialConfiguration() {
    CF::PropertySet::PartialConfiguration::insertToAnyFn = _0RL_insertToAny__cCF_mPropertySet_mPartialConfiguration;
    CF::PropertySet::PartialConfiguration::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mPropertySet_mPartialConfiguration;
  }
};
static _0RL_insertToAny_Singleton__cCF_mPropertySet_mPartialConfiguration _0RL_insertToAny_Singleton__cCF_mPropertySet_mPartialConfiguration_;

static void _0RL_CF_mPropertySet_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mPropertySet_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::PropertySet::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mPropertySet_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::PropertySet_ptr _o)
{
  CF::PropertySet_ptr _no = CF::PropertySet::_duplicate(_o);
  _a.PR_insert(CF::_tc_PropertySet,
               _0RL_CF_mPropertySet_marshal_fn,
               _0RL_CF_mPropertySet_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::PropertySet_ptr* _op)
{
  _a.PR_insert(CF::_tc_PropertySet,
               _0RL_CF_mPropertySet_marshal_fn,
               _0RL_CF_mPropertySet_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::PropertySet::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::PropertySet_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_PropertySet,
                    _0RL_CF_mPropertySet_unmarshal_fn,
                    _0RL_CF_mPropertySet_marshal_fn,
                    _0RL_CF_mPropertySet_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::PropertySet_ptr)_r->_ptrToObjRef(CF::PropertySet::_PD_repoId);
    else
      _o = CF::PropertySet::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mDomainManager_mApplicationInstallationError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::ApplicationInstallationError* _p = (const CF::DomainManager::ApplicationInstallationError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mApplicationInstallationError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::ApplicationInstallationError* _p = new CF::DomainManager::ApplicationInstallationError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mApplicationInstallationError_destructor_fn(void* _v)
{
  CF::DomainManager::ApplicationInstallationError* _p = (CF::DomainManager::ApplicationInstallationError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError& _s)
{
  CF::DomainManager::ApplicationInstallationError* _p = new CF::DomainManager::ApplicationInstallationError(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mApplicationInstallationError,
               _0RL_CF_mDomainManager_mApplicationInstallationError_marshal_fn,
               _0RL_CF_mDomainManager_mApplicationInstallationError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mApplicationInstallationError,
               _0RL_CF_mDomainManager_mApplicationInstallationError_marshal_fn,
               _0RL_CF_mDomainManager_mApplicationInstallationError_destructor_fn,
               (CF::DomainManager::ApplicationInstallationError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mApplicationInstallationError,
                    _0RL_CF_mDomainManager_mApplicationInstallationError_unmarshal_fn,
                    _0RL_CF_mDomainManager_mApplicationInstallationError_marshal_fn,
                    _0RL_CF_mDomainManager_mApplicationInstallationError_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::ApplicationInstallationError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mApplicationInstallationError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::ApplicationInstallationError & _ex = (const CF::DomainManager::ApplicationInstallationError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mApplicationInstallationError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::ApplicationInstallationError* _ex = (const CF::DomainManager::ApplicationInstallationError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mApplicationInstallationError {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mApplicationInstallationError() {
    CF::DomainManager::ApplicationInstallationError::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mApplicationInstallationError;
    CF::DomainManager::ApplicationInstallationError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mApplicationInstallationError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mApplicationInstallationError _0RL_insertToAny_Singleton__cCF_mDomainManager_mApplicationInstallationError_;

static void _0RL_CF_mDomainManager_mApplicationSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DomainManager::ApplicationSequence* _p = (CF::DomainManager::ApplicationSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mApplicationSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::ApplicationSequence* _p = new CF::DomainManager::ApplicationSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mApplicationSequence_destructor_fn(void* _v)
{
  CF::DomainManager::ApplicationSequence* _p = (CF::DomainManager::ApplicationSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationSequence& _s)
{
  CF::DomainManager::ApplicationSequence* _p = new CF::DomainManager::ApplicationSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mApplicationSequence,
               _0RL_CF_mDomainManager_mApplicationSequence_marshal_fn,
               _0RL_CF_mDomainManager_mApplicationSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DomainManager::ApplicationSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mApplicationSequence,
               _0RL_CF_mDomainManager_mApplicationSequence_marshal_fn,
               _0RL_CF_mDomainManager_mApplicationSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::ApplicationSequence*& _sp)
{
  return _a >>= (const CF::DomainManager::ApplicationSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mApplicationSequence,
                    _0RL_CF_mDomainManager_mApplicationSequence_unmarshal_fn,
                    _0RL_CF_mDomainManager_mApplicationSequence_marshal_fn,
                    _0RL_CF_mDomainManager_mApplicationSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::ApplicationSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mDomainManager_mApplicationFactorySequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DomainManager::ApplicationFactorySequence* _p = (CF::DomainManager::ApplicationFactorySequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mApplicationFactorySequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::ApplicationFactorySequence* _p = new CF::DomainManager::ApplicationFactorySequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mApplicationFactorySequence_destructor_fn(void* _v)
{
  CF::DomainManager::ApplicationFactorySequence* _p = (CF::DomainManager::ApplicationFactorySequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationFactorySequence& _s)
{
  CF::DomainManager::ApplicationFactorySequence* _p = new CF::DomainManager::ApplicationFactorySequence(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mApplicationFactorySequence,
               _0RL_CF_mDomainManager_mApplicationFactorySequence_marshal_fn,
               _0RL_CF_mDomainManager_mApplicationFactorySequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DomainManager::ApplicationFactorySequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mApplicationFactorySequence,
               _0RL_CF_mDomainManager_mApplicationFactorySequence_marshal_fn,
               _0RL_CF_mDomainManager_mApplicationFactorySequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::ApplicationFactorySequence*& _sp)
{
  return _a >>= (const CF::DomainManager::ApplicationFactorySequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationFactorySequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mApplicationFactorySequence,
                    _0RL_CF_mDomainManager_mApplicationFactorySequence_unmarshal_fn,
                    _0RL_CF_mDomainManager_mApplicationFactorySequence_marshal_fn,
                    _0RL_CF_mDomainManager_mApplicationFactorySequence_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::ApplicationFactorySequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mDomainManager_mDeviceManagerSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DomainManager::DeviceManagerSequence* _p = (CF::DomainManager::DeviceManagerSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mDeviceManagerSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::DeviceManagerSequence* _p = new CF::DomainManager::DeviceManagerSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mDeviceManagerSequence_destructor_fn(void* _v)
{
  CF::DomainManager::DeviceManagerSequence* _p = (CF::DomainManager::DeviceManagerSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerSequence& _s)
{
  CF::DomainManager::DeviceManagerSequence* _p = new CF::DomainManager::DeviceManagerSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mDeviceManagerSequence,
               _0RL_CF_mDomainManager_mDeviceManagerSequence_marshal_fn,
               _0RL_CF_mDomainManager_mDeviceManagerSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DomainManager::DeviceManagerSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mDeviceManagerSequence,
               _0RL_CF_mDomainManager_mDeviceManagerSequence_marshal_fn,
               _0RL_CF_mDomainManager_mDeviceManagerSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::DeviceManagerSequence*& _sp)
{
  return _a >>= (const CF::DomainManager::DeviceManagerSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::DeviceManagerSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mDeviceManagerSequence,
                    _0RL_CF_mDomainManager_mDeviceManagerSequence_unmarshal_fn,
                    _0RL_CF_mDomainManager_mDeviceManagerSequence_marshal_fn,
                    _0RL_CF_mDomainManager_mDeviceManagerSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::DeviceManagerSequence*)_v;
    return 1;
  }
  return 0;
}


static void _0RL_CF_mDomainManager_mInvalidIdentifier_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::InvalidIdentifier* _p = (const CF::DomainManager::InvalidIdentifier*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mInvalidIdentifier_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::InvalidIdentifier* _p = new CF::DomainManager::InvalidIdentifier;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mInvalidIdentifier_destructor_fn(void* _v)
{
  CF::DomainManager::InvalidIdentifier* _p = (CF::DomainManager::InvalidIdentifier*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier& _s)
{
  CF::DomainManager::InvalidIdentifier* _p = new CF::DomainManager::InvalidIdentifier(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mInvalidIdentifier,
               _0RL_CF_mDomainManager_mInvalidIdentifier_marshal_fn,
               _0RL_CF_mDomainManager_mInvalidIdentifier_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mInvalidIdentifier,
               _0RL_CF_mDomainManager_mInvalidIdentifier_marshal_fn,
               _0RL_CF_mDomainManager_mInvalidIdentifier_destructor_fn,
               (CF::DomainManager::InvalidIdentifier*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mInvalidIdentifier,
                    _0RL_CF_mDomainManager_mInvalidIdentifier_unmarshal_fn,
                    _0RL_CF_mDomainManager_mInvalidIdentifier_marshal_fn,
                    _0RL_CF_mDomainManager_mInvalidIdentifier_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::InvalidIdentifier*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mInvalidIdentifier(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::InvalidIdentifier & _ex = (const CF::DomainManager::InvalidIdentifier &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mInvalidIdentifier (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::InvalidIdentifier* _ex = (const CF::DomainManager::InvalidIdentifier*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mInvalidIdentifier {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mInvalidIdentifier() {
    CF::DomainManager::InvalidIdentifier::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mInvalidIdentifier;
    CF::DomainManager::InvalidIdentifier::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mInvalidIdentifier;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mInvalidIdentifier _0RL_insertToAny_Singleton__cCF_mDomainManager_mInvalidIdentifier_;


static void _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::DeviceManagerNotRegistered* _p = (const CF::DomainManager::DeviceManagerNotRegistered*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::DeviceManagerNotRegistered* _p = new CF::DomainManager::DeviceManagerNotRegistered;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_destructor_fn(void* _v)
{
  CF::DomainManager::DeviceManagerNotRegistered* _p = (CF::DomainManager::DeviceManagerNotRegistered*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered& _s)
{
  CF::DomainManager::DeviceManagerNotRegistered* _p = new CF::DomainManager::DeviceManagerNotRegistered(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mDeviceManagerNotRegistered,
               _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_marshal_fn,
               _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mDeviceManagerNotRegistered,
               _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_marshal_fn,
               _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_destructor_fn,
               (CF::DomainManager::DeviceManagerNotRegistered*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mDeviceManagerNotRegistered,
                    _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_unmarshal_fn,
                    _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_marshal_fn,
                    _0RL_CF_mDomainManager_mDeviceManagerNotRegistered_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::DeviceManagerNotRegistered*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mDeviceManagerNotRegistered(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::DeviceManagerNotRegistered & _ex = (const CF::DomainManager::DeviceManagerNotRegistered &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mDeviceManagerNotRegistered (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::DeviceManagerNotRegistered* _ex = (const CF::DomainManager::DeviceManagerNotRegistered*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mDeviceManagerNotRegistered {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mDeviceManagerNotRegistered() {
    CF::DomainManager::DeviceManagerNotRegistered::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mDeviceManagerNotRegistered;
    CF::DomainManager::DeviceManagerNotRegistered::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mDeviceManagerNotRegistered;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mDeviceManagerNotRegistered _0RL_insertToAny_Singleton__cCF_mDomainManager_mDeviceManagerNotRegistered_;


static void _0RL_CF_mDomainManager_mApplicationUninstallationError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::ApplicationUninstallationError* _p = (const CF::DomainManager::ApplicationUninstallationError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mApplicationUninstallationError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::ApplicationUninstallationError* _p = new CF::DomainManager::ApplicationUninstallationError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mApplicationUninstallationError_destructor_fn(void* _v)
{
  CF::DomainManager::ApplicationUninstallationError* _p = (CF::DomainManager::ApplicationUninstallationError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError& _s)
{
  CF::DomainManager::ApplicationUninstallationError* _p = new CF::DomainManager::ApplicationUninstallationError(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mApplicationUninstallationError,
               _0RL_CF_mDomainManager_mApplicationUninstallationError_marshal_fn,
               _0RL_CF_mDomainManager_mApplicationUninstallationError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mApplicationUninstallationError,
               _0RL_CF_mDomainManager_mApplicationUninstallationError_marshal_fn,
               _0RL_CF_mDomainManager_mApplicationUninstallationError_destructor_fn,
               (CF::DomainManager::ApplicationUninstallationError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mApplicationUninstallationError,
                    _0RL_CF_mDomainManager_mApplicationUninstallationError_unmarshal_fn,
                    _0RL_CF_mDomainManager_mApplicationUninstallationError_marshal_fn,
                    _0RL_CF_mDomainManager_mApplicationUninstallationError_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::ApplicationUninstallationError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mApplicationUninstallationError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::ApplicationUninstallationError & _ex = (const CF::DomainManager::ApplicationUninstallationError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mApplicationUninstallationError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::ApplicationUninstallationError* _ex = (const CF::DomainManager::ApplicationUninstallationError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mApplicationUninstallationError {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mApplicationUninstallationError() {
    CF::DomainManager::ApplicationUninstallationError::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mApplicationUninstallationError;
    CF::DomainManager::ApplicationUninstallationError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mApplicationUninstallationError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mApplicationUninstallationError _0RL_insertToAny_Singleton__cCF_mDomainManager_mApplicationUninstallationError_;


static void _0RL_CF_mDomainManager_mRegisterError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::RegisterError* _p = (const CF::DomainManager::RegisterError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mRegisterError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::RegisterError* _p = new CF::DomainManager::RegisterError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mRegisterError_destructor_fn(void* _v)
{
  CF::DomainManager::RegisterError* _p = (CF::DomainManager::RegisterError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::RegisterError& _s)
{
  CF::DomainManager::RegisterError* _p = new CF::DomainManager::RegisterError(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mRegisterError,
               _0RL_CF_mDomainManager_mRegisterError_marshal_fn,
               _0RL_CF_mDomainManager_mRegisterError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::RegisterError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mRegisterError,
               _0RL_CF_mDomainManager_mRegisterError_marshal_fn,
               _0RL_CF_mDomainManager_mRegisterError_destructor_fn,
               (CF::DomainManager::RegisterError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::RegisterError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mRegisterError,
                    _0RL_CF_mDomainManager_mRegisterError_unmarshal_fn,
                    _0RL_CF_mDomainManager_mRegisterError_marshal_fn,
                    _0RL_CF_mDomainManager_mRegisterError_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::RegisterError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mRegisterError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::RegisterError & _ex = (const CF::DomainManager::RegisterError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mRegisterError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::RegisterError* _ex = (const CF::DomainManager::RegisterError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mRegisterError {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mRegisterError() {
    CF::DomainManager::RegisterError::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mRegisterError;
    CF::DomainManager::RegisterError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mRegisterError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mRegisterError _0RL_insertToAny_Singleton__cCF_mDomainManager_mRegisterError_;


static void _0RL_CF_mDomainManager_mUnregisterError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::UnregisterError* _p = (const CF::DomainManager::UnregisterError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mUnregisterError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::UnregisterError* _p = new CF::DomainManager::UnregisterError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mUnregisterError_destructor_fn(void* _v)
{
  CF::DomainManager::UnregisterError* _p = (CF::DomainManager::UnregisterError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::UnregisterError& _s)
{
  CF::DomainManager::UnregisterError* _p = new CF::DomainManager::UnregisterError(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mUnregisterError,
               _0RL_CF_mDomainManager_mUnregisterError_marshal_fn,
               _0RL_CF_mDomainManager_mUnregisterError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::UnregisterError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mUnregisterError,
               _0RL_CF_mDomainManager_mUnregisterError_marshal_fn,
               _0RL_CF_mDomainManager_mUnregisterError_destructor_fn,
               (CF::DomainManager::UnregisterError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::UnregisterError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mUnregisterError,
                    _0RL_CF_mDomainManager_mUnregisterError_unmarshal_fn,
                    _0RL_CF_mDomainManager_mUnregisterError_marshal_fn,
                    _0RL_CF_mDomainManager_mUnregisterError_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::UnregisterError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mUnregisterError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::UnregisterError & _ex = (const CF::DomainManager::UnregisterError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mUnregisterError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::UnregisterError* _ex = (const CF::DomainManager::UnregisterError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mUnregisterError {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mUnregisterError() {
    CF::DomainManager::UnregisterError::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mUnregisterError;
    CF::DomainManager::UnregisterError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mUnregisterError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mUnregisterError _0RL_insertToAny_Singleton__cCF_mDomainManager_mUnregisterError_;


static void _0RL_CF_mDomainManager_mAlreadyConnected_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::AlreadyConnected* _p = (const CF::DomainManager::AlreadyConnected*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mAlreadyConnected_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::AlreadyConnected* _p = new CF::DomainManager::AlreadyConnected;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mAlreadyConnected_destructor_fn(void* _v)
{
  CF::DomainManager::AlreadyConnected* _p = (CF::DomainManager::AlreadyConnected*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected& _s)
{
  CF::DomainManager::AlreadyConnected* _p = new CF::DomainManager::AlreadyConnected(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mAlreadyConnected,
               _0RL_CF_mDomainManager_mAlreadyConnected_marshal_fn,
               _0RL_CF_mDomainManager_mAlreadyConnected_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mAlreadyConnected,
               _0RL_CF_mDomainManager_mAlreadyConnected_marshal_fn,
               _0RL_CF_mDomainManager_mAlreadyConnected_destructor_fn,
               (CF::DomainManager::AlreadyConnected*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mAlreadyConnected,
                    _0RL_CF_mDomainManager_mAlreadyConnected_unmarshal_fn,
                    _0RL_CF_mDomainManager_mAlreadyConnected_marshal_fn,
                    _0RL_CF_mDomainManager_mAlreadyConnected_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::AlreadyConnected*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mAlreadyConnected(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::AlreadyConnected & _ex = (const CF::DomainManager::AlreadyConnected &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mAlreadyConnected (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::AlreadyConnected* _ex = (const CF::DomainManager::AlreadyConnected*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mAlreadyConnected {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mAlreadyConnected() {
    CF::DomainManager::AlreadyConnected::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mAlreadyConnected;
    CF::DomainManager::AlreadyConnected::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mAlreadyConnected;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mAlreadyConnected _0RL_insertToAny_Singleton__cCF_mDomainManager_mAlreadyConnected_;


static void _0RL_CF_mDomainManager_mInvalidEventChannelName_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::InvalidEventChannelName* _p = (const CF::DomainManager::InvalidEventChannelName*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mInvalidEventChannelName_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::InvalidEventChannelName* _p = new CF::DomainManager::InvalidEventChannelName;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mInvalidEventChannelName_destructor_fn(void* _v)
{
  CF::DomainManager::InvalidEventChannelName* _p = (CF::DomainManager::InvalidEventChannelName*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName& _s)
{
  CF::DomainManager::InvalidEventChannelName* _p = new CF::DomainManager::InvalidEventChannelName(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mInvalidEventChannelName,
               _0RL_CF_mDomainManager_mInvalidEventChannelName_marshal_fn,
               _0RL_CF_mDomainManager_mInvalidEventChannelName_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mInvalidEventChannelName,
               _0RL_CF_mDomainManager_mInvalidEventChannelName_marshal_fn,
               _0RL_CF_mDomainManager_mInvalidEventChannelName_destructor_fn,
               (CF::DomainManager::InvalidEventChannelName*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mInvalidEventChannelName,
                    _0RL_CF_mDomainManager_mInvalidEventChannelName_unmarshal_fn,
                    _0RL_CF_mDomainManager_mInvalidEventChannelName_marshal_fn,
                    _0RL_CF_mDomainManager_mInvalidEventChannelName_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::InvalidEventChannelName*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mInvalidEventChannelName(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::InvalidEventChannelName & _ex = (const CF::DomainManager::InvalidEventChannelName &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mInvalidEventChannelName (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::InvalidEventChannelName* _ex = (const CF::DomainManager::InvalidEventChannelName*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mInvalidEventChannelName {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mInvalidEventChannelName() {
    CF::DomainManager::InvalidEventChannelName::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mInvalidEventChannelName;
    CF::DomainManager::InvalidEventChannelName::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mInvalidEventChannelName;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mInvalidEventChannelName _0RL_insertToAny_Singleton__cCF_mDomainManager_mInvalidEventChannelName_;


static void _0RL_CF_mDomainManager_mNotConnected_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::DomainManager::NotConnected* _p = (const CF::DomainManager::NotConnected*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDomainManager_mNotConnected_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DomainManager::NotConnected* _p = new CF::DomainManager::NotConnected;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDomainManager_mNotConnected_destructor_fn(void* _v)
{
  CF::DomainManager::NotConnected* _p = (CF::DomainManager::NotConnected*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::NotConnected& _s)
{
  CF::DomainManager::NotConnected* _p = new CF::DomainManager::NotConnected(_s);
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mNotConnected,
               _0RL_CF_mDomainManager_mNotConnected_marshal_fn,
               _0RL_CF_mDomainManager_mNotConnected_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::NotConnected* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDomainManager_mNotConnected,
               _0RL_CF_mDomainManager_mNotConnected_marshal_fn,
               _0RL_CF_mDomainManager_mNotConnected_destructor_fn,
               (CF::DomainManager::NotConnected*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::NotConnected*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDomainManager_mNotConnected,
                    _0RL_CF_mDomainManager_mNotConnected_unmarshal_fn,
                    _0RL_CF_mDomainManager_mNotConnected_marshal_fn,
                    _0RL_CF_mDomainManager_mNotConnected_destructor_fn,
                    _v)) {
    _sp = (const CF::DomainManager::NotConnected*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDomainManager_mNotConnected(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::DomainManager::NotConnected & _ex = (const CF::DomainManager::NotConnected &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDomainManager_mNotConnected (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::DomainManager::NotConnected* _ex = (const CF::DomainManager::NotConnected*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDomainManager_mNotConnected {
public:
  _0RL_insertToAny_Singleton__cCF_mDomainManager_mNotConnected() {
    CF::DomainManager::NotConnected::insertToAnyFn = _0RL_insertToAny__cCF_mDomainManager_mNotConnected;
    CF::DomainManager::NotConnected::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDomainManager_mNotConnected;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDomainManager_mNotConnected _0RL_insertToAny_Singleton__cCF_mDomainManager_mNotConnected_;

static void _0RL_CF_mDomainManager_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mDomainManager_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::DomainManager::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mDomainManager_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::DomainManager_ptr _o)
{
  CF::DomainManager_ptr _no = CF::DomainManager::_duplicate(_o);
  _a.PR_insert(CF::_tc_DomainManager,
               _0RL_CF_mDomainManager_marshal_fn,
               _0RL_CF_mDomainManager_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::DomainManager_ptr* _op)
{
  _a.PR_insert(CF::_tc_DomainManager,
               _0RL_CF_mDomainManager_marshal_fn,
               _0RL_CF_mDomainManager_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::DomainManager::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_DomainManager,
                    _0RL_CF_mDomainManager_unmarshal_fn,
                    _0RL_CF_mDomainManager_marshal_fn,
                    _0RL_CF_mDomainManager_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::DomainManager_ptr)_r->_ptrToObjRef(CF::DomainManager::_PD_repoId);
    else
      _o = CF::DomainManager::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ApplicationFactory::CreateApplicationRequestError* _p = (const CF::ApplicationFactory::CreateApplicationRequestError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ApplicationFactory::CreateApplicationRequestError* _p = new CF::ApplicationFactory::CreateApplicationRequestError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_destructor_fn(void* _v)
{
  CF::ApplicationFactory::CreateApplicationRequestError* _p = (CF::ApplicationFactory::CreateApplicationRequestError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError& _s)
{
  CF::ApplicationFactory::CreateApplicationRequestError* _p = new CF::ApplicationFactory::CreateApplicationRequestError(_s);
  _a.PR_insert(_0RL_tc_CF_mApplicationFactory_mCreateApplicationRequestError,
               _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_marshal_fn,
               _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mApplicationFactory_mCreateApplicationRequestError,
               _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_marshal_fn,
               _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_destructor_fn,
               (CF::ApplicationFactory::CreateApplicationRequestError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mApplicationFactory_mCreateApplicationRequestError,
                    _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_unmarshal_fn,
                    _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_marshal_fn,
                    _0RL_CF_mApplicationFactory_mCreateApplicationRequestError_destructor_fn,
                    _v)) {
    _sp = (const CF::ApplicationFactory::CreateApplicationRequestError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mApplicationFactory_mCreateApplicationRequestError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ApplicationFactory::CreateApplicationRequestError & _ex = (const CF::ApplicationFactory::CreateApplicationRequestError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mApplicationFactory_mCreateApplicationRequestError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ApplicationFactory::CreateApplicationRequestError* _ex = (const CF::ApplicationFactory::CreateApplicationRequestError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mCreateApplicationRequestError {
public:
  _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mCreateApplicationRequestError() {
    CF::ApplicationFactory::CreateApplicationRequestError::insertToAnyFn = _0RL_insertToAny__cCF_mApplicationFactory_mCreateApplicationRequestError;
    CF::ApplicationFactory::CreateApplicationRequestError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mApplicationFactory_mCreateApplicationRequestError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mCreateApplicationRequestError _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mCreateApplicationRequestError_;


static void _0RL_CF_mApplicationFactory_mCreateApplicationError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ApplicationFactory::CreateApplicationError* _p = (const CF::ApplicationFactory::CreateApplicationError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mApplicationFactory_mCreateApplicationError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ApplicationFactory::CreateApplicationError* _p = new CF::ApplicationFactory::CreateApplicationError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mApplicationFactory_mCreateApplicationError_destructor_fn(void* _v)
{
  CF::ApplicationFactory::CreateApplicationError* _p = (CF::ApplicationFactory::CreateApplicationError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError& _s)
{
  CF::ApplicationFactory::CreateApplicationError* _p = new CF::ApplicationFactory::CreateApplicationError(_s);
  _a.PR_insert(_0RL_tc_CF_mApplicationFactory_mCreateApplicationError,
               _0RL_CF_mApplicationFactory_mCreateApplicationError_marshal_fn,
               _0RL_CF_mApplicationFactory_mCreateApplicationError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mApplicationFactory_mCreateApplicationError,
               _0RL_CF_mApplicationFactory_mCreateApplicationError_marshal_fn,
               _0RL_CF_mApplicationFactory_mCreateApplicationError_destructor_fn,
               (CF::ApplicationFactory::CreateApplicationError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mApplicationFactory_mCreateApplicationError,
                    _0RL_CF_mApplicationFactory_mCreateApplicationError_unmarshal_fn,
                    _0RL_CF_mApplicationFactory_mCreateApplicationError_marshal_fn,
                    _0RL_CF_mApplicationFactory_mCreateApplicationError_destructor_fn,
                    _v)) {
    _sp = (const CF::ApplicationFactory::CreateApplicationError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mApplicationFactory_mCreateApplicationError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ApplicationFactory::CreateApplicationError & _ex = (const CF::ApplicationFactory::CreateApplicationError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mApplicationFactory_mCreateApplicationError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ApplicationFactory::CreateApplicationError* _ex = (const CF::ApplicationFactory::CreateApplicationError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mCreateApplicationError {
public:
  _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mCreateApplicationError() {
    CF::ApplicationFactory::CreateApplicationError::insertToAnyFn = _0RL_insertToAny__cCF_mApplicationFactory_mCreateApplicationError;
    CF::ApplicationFactory::CreateApplicationError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mApplicationFactory_mCreateApplicationError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mCreateApplicationError _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mCreateApplicationError_;


static void _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ApplicationFactory::InvalidInitConfiguration* _p = (const CF::ApplicationFactory::InvalidInitConfiguration*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ApplicationFactory::InvalidInitConfiguration* _p = new CF::ApplicationFactory::InvalidInitConfiguration;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_destructor_fn(void* _v)
{
  CF::ApplicationFactory::InvalidInitConfiguration* _p = (CF::ApplicationFactory::InvalidInitConfiguration*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration& _s)
{
  CF::ApplicationFactory::InvalidInitConfiguration* _p = new CF::ApplicationFactory::InvalidInitConfiguration(_s);
  _a.PR_insert(_0RL_tc_CF_mApplicationFactory_mInvalidInitConfiguration,
               _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_marshal_fn,
               _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mApplicationFactory_mInvalidInitConfiguration,
               _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_marshal_fn,
               _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_destructor_fn,
               (CF::ApplicationFactory::InvalidInitConfiguration*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mApplicationFactory_mInvalidInitConfiguration,
                    _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_unmarshal_fn,
                    _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_marshal_fn,
                    _0RL_CF_mApplicationFactory_mInvalidInitConfiguration_destructor_fn,
                    _v)) {
    _sp = (const CF::ApplicationFactory::InvalidInitConfiguration*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mApplicationFactory_mInvalidInitConfiguration(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ApplicationFactory::InvalidInitConfiguration & _ex = (const CF::ApplicationFactory::InvalidInitConfiguration &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mApplicationFactory_mInvalidInitConfiguration (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ApplicationFactory::InvalidInitConfiguration* _ex = (const CF::ApplicationFactory::InvalidInitConfiguration*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mInvalidInitConfiguration {
public:
  _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mInvalidInitConfiguration() {
    CF::ApplicationFactory::InvalidInitConfiguration::insertToAnyFn = _0RL_insertToAny__cCF_mApplicationFactory_mInvalidInitConfiguration;
    CF::ApplicationFactory::InvalidInitConfiguration::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mApplicationFactory_mInvalidInitConfiguration;
  }
};
static _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mInvalidInitConfiguration _0RL_insertToAny_Singleton__cCF_mApplicationFactory_mInvalidInitConfiguration_;

static void _0RL_CF_mApplicationFactory_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mApplicationFactory_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::ApplicationFactory::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mApplicationFactory_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::ApplicationFactory_ptr _o)
{
  CF::ApplicationFactory_ptr _no = CF::ApplicationFactory::_duplicate(_o);
  _a.PR_insert(CF::_tc_ApplicationFactory,
               _0RL_CF_mApplicationFactory_marshal_fn,
               _0RL_CF_mApplicationFactory_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::ApplicationFactory_ptr* _op)
{
  _a.PR_insert(CF::_tc_ApplicationFactory,
               _0RL_CF_mApplicationFactory_marshal_fn,
               _0RL_CF_mApplicationFactory_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::ApplicationFactory::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::ApplicationFactory_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_ApplicationFactory,
                    _0RL_CF_mApplicationFactory_unmarshal_fn,
                    _0RL_CF_mApplicationFactory_marshal_fn,
                    _0RL_CF_mApplicationFactory_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::ApplicationFactory_ptr)_r->_ptrToObjRef(CF::ApplicationFactory::_PD_repoId);
    else
      _o = CF::ApplicationFactory::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mPortSupplier_mUnknownPort_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::PortSupplier::UnknownPort* _p = (const CF::PortSupplier::UnknownPort*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mPortSupplier_mUnknownPort_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::PortSupplier::UnknownPort* _p = new CF::PortSupplier::UnknownPort;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mPortSupplier_mUnknownPort_destructor_fn(void* _v)
{
  CF::PortSupplier::UnknownPort* _p = (CF::PortSupplier::UnknownPort*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::PortSupplier::UnknownPort& _s)
{
  CF::PortSupplier::UnknownPort* _p = new CF::PortSupplier::UnknownPort(_s);
  _a.PR_insert(_0RL_tc_CF_mPortSupplier_mUnknownPort,
               _0RL_CF_mPortSupplier_mUnknownPort_marshal_fn,
               _0RL_CF_mPortSupplier_mUnknownPort_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::PortSupplier::UnknownPort* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mPortSupplier_mUnknownPort,
               _0RL_CF_mPortSupplier_mUnknownPort_marshal_fn,
               _0RL_CF_mPortSupplier_mUnknownPort_destructor_fn,
               (CF::PortSupplier::UnknownPort*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::PortSupplier::UnknownPort*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mPortSupplier_mUnknownPort,
                    _0RL_CF_mPortSupplier_mUnknownPort_unmarshal_fn,
                    _0RL_CF_mPortSupplier_mUnknownPort_marshal_fn,
                    _0RL_CF_mPortSupplier_mUnknownPort_destructor_fn,
                    _v)) {
    _sp = (const CF::PortSupplier::UnknownPort*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mPortSupplier_mUnknownPort(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::PortSupplier::UnknownPort & _ex = (const CF::PortSupplier::UnknownPort &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mPortSupplier_mUnknownPort (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::PortSupplier::UnknownPort* _ex = (const CF::PortSupplier::UnknownPort*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mPortSupplier_mUnknownPort {
public:
  _0RL_insertToAny_Singleton__cCF_mPortSupplier_mUnknownPort() {
    CF::PortSupplier::UnknownPort::insertToAnyFn = _0RL_insertToAny__cCF_mPortSupplier_mUnknownPort;
    CF::PortSupplier::UnknownPort::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mPortSupplier_mUnknownPort;
  }
};
static _0RL_insertToAny_Singleton__cCF_mPortSupplier_mUnknownPort _0RL_insertToAny_Singleton__cCF_mPortSupplier_mUnknownPort_;

static void _0RL_CF_mPortSupplier_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mPortSupplier_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::PortSupplier::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mPortSupplier_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::PortSupplier_ptr _o)
{
  CF::PortSupplier_ptr _no = CF::PortSupplier::_duplicate(_o);
  _a.PR_insert(CF::_tc_PortSupplier,
               _0RL_CF_mPortSupplier_marshal_fn,
               _0RL_CF_mPortSupplier_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::PortSupplier_ptr* _op)
{
  _a.PR_insert(CF::_tc_PortSupplier,
               _0RL_CF_mPortSupplier_marshal_fn,
               _0RL_CF_mPortSupplier_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::PortSupplier::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::PortSupplier_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_PortSupplier,
                    _0RL_CF_mPortSupplier_unmarshal_fn,
                    _0RL_CF_mPortSupplier_marshal_fn,
                    _0RL_CF_mPortSupplier_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::PortSupplier_ptr)_r->_ptrToObjRef(CF::PortSupplier::_PD_repoId);
    else
      _o = CF::PortSupplier::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mResource_mStartError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::Resource::StartError* _p = (const CF::Resource::StartError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mResource_mStartError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Resource::StartError* _p = new CF::Resource::StartError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mResource_mStartError_destructor_fn(void* _v)
{
  CF::Resource::StartError* _p = (CF::Resource::StartError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Resource::StartError& _s)
{
  CF::Resource::StartError* _p = new CF::Resource::StartError(_s);
  _a.PR_insert(_0RL_tc_CF_mResource_mStartError,
               _0RL_CF_mResource_mStartError_marshal_fn,
               _0RL_CF_mResource_mStartError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::Resource::StartError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mResource_mStartError,
               _0RL_CF_mResource_mStartError_marshal_fn,
               _0RL_CF_mResource_mStartError_destructor_fn,
               (CF::Resource::StartError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Resource::StartError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mResource_mStartError,
                    _0RL_CF_mResource_mStartError_unmarshal_fn,
                    _0RL_CF_mResource_mStartError_marshal_fn,
                    _0RL_CF_mResource_mStartError_destructor_fn,
                    _v)) {
    _sp = (const CF::Resource::StartError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mResource_mStartError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::Resource::StartError & _ex = (const CF::Resource::StartError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mResource_mStartError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::Resource::StartError* _ex = (const CF::Resource::StartError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mResource_mStartError {
public:
  _0RL_insertToAny_Singleton__cCF_mResource_mStartError() {
    CF::Resource::StartError::insertToAnyFn = _0RL_insertToAny__cCF_mResource_mStartError;
    CF::Resource::StartError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mResource_mStartError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mResource_mStartError _0RL_insertToAny_Singleton__cCF_mResource_mStartError_;


static void _0RL_CF_mResource_mStopError_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::Resource::StopError* _p = (const CF::Resource::StopError*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mResource_mStopError_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Resource::StopError* _p = new CF::Resource::StopError;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mResource_mStopError_destructor_fn(void* _v)
{
  CF::Resource::StopError* _p = (CF::Resource::StopError*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Resource::StopError& _s)
{
  CF::Resource::StopError* _p = new CF::Resource::StopError(_s);
  _a.PR_insert(_0RL_tc_CF_mResource_mStopError,
               _0RL_CF_mResource_mStopError_marshal_fn,
               _0RL_CF_mResource_mStopError_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::Resource::StopError* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mResource_mStopError,
               _0RL_CF_mResource_mStopError_marshal_fn,
               _0RL_CF_mResource_mStopError_destructor_fn,
               (CF::Resource::StopError*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Resource::StopError*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mResource_mStopError,
                    _0RL_CF_mResource_mStopError_unmarshal_fn,
                    _0RL_CF_mResource_mStopError_marshal_fn,
                    _0RL_CF_mResource_mStopError_destructor_fn,
                    _v)) {
    _sp = (const CF::Resource::StopError*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mResource_mStopError(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::Resource::StopError & _ex = (const CF::Resource::StopError &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mResource_mStopError (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::Resource::StopError* _ex = (const CF::Resource::StopError*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mResource_mStopError {
public:
  _0RL_insertToAny_Singleton__cCF_mResource_mStopError() {
    CF::Resource::StopError::insertToAnyFn = _0RL_insertToAny__cCF_mResource_mStopError;
    CF::Resource::StopError::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mResource_mStopError;
  }
};
static _0RL_insertToAny_Singleton__cCF_mResource_mStopError _0RL_insertToAny_Singleton__cCF_mResource_mStopError_;

static void _0RL_CF_mResource_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mResource_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::Resource::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mResource_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::Resource_ptr _o)
{
  CF::Resource_ptr _no = CF::Resource::_duplicate(_o);
  _a.PR_insert(CF::_tc_Resource,
               _0RL_CF_mResource_marshal_fn,
               _0RL_CF_mResource_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::Resource_ptr* _op)
{
  _a.PR_insert(CF::_tc_Resource,
               _0RL_CF_mResource_marshal_fn,
               _0RL_CF_mResource_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::Resource::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Resource_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_Resource,
                    _0RL_CF_mResource_unmarshal_fn,
                    _0RL_CF_mResource_marshal_fn,
                    _0RL_CF_mResource_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::Resource_ptr)_r->_ptrToObjRef(CF::Resource::_PD_repoId);
    else
      _o = CF::Resource::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mDevice_mInvalidState_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::Device::InvalidState* _p = (const CF::Device::InvalidState*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDevice_mInvalidState_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Device::InvalidState* _p = new CF::Device::InvalidState;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDevice_mInvalidState_destructor_fn(void* _v)
{
  CF::Device::InvalidState* _p = (CF::Device::InvalidState*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidState& _s)
{
  CF::Device::InvalidState* _p = new CF::Device::InvalidState(_s);
  _a.PR_insert(_0RL_tc_CF_mDevice_mInvalidState,
               _0RL_CF_mDevice_mInvalidState_marshal_fn,
               _0RL_CF_mDevice_mInvalidState_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidState* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDevice_mInvalidState,
               _0RL_CF_mDevice_mInvalidState_marshal_fn,
               _0RL_CF_mDevice_mInvalidState_destructor_fn,
               (CF::Device::InvalidState*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Device::InvalidState*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDevice_mInvalidState,
                    _0RL_CF_mDevice_mInvalidState_unmarshal_fn,
                    _0RL_CF_mDevice_mInvalidState_marshal_fn,
                    _0RL_CF_mDevice_mInvalidState_destructor_fn,
                    _v)) {
    _sp = (const CF::Device::InvalidState*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDevice_mInvalidState(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::Device::InvalidState & _ex = (const CF::Device::InvalidState &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDevice_mInvalidState (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::Device::InvalidState* _ex = (const CF::Device::InvalidState*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDevice_mInvalidState {
public:
  _0RL_insertToAny_Singleton__cCF_mDevice_mInvalidState() {
    CF::Device::InvalidState::insertToAnyFn = _0RL_insertToAny__cCF_mDevice_mInvalidState;
    CF::Device::InvalidState::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDevice_mInvalidState;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDevice_mInvalidState _0RL_insertToAny_Singleton__cCF_mDevice_mInvalidState_;


static void _0RL_CF_mDevice_mInvalidCapacity_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::Device::InvalidCapacity* _p = (const CF::Device::InvalidCapacity*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDevice_mInvalidCapacity_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Device::InvalidCapacity* _p = new CF::Device::InvalidCapacity;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDevice_mInvalidCapacity_destructor_fn(void* _v)
{
  CF::Device::InvalidCapacity* _p = (CF::Device::InvalidCapacity*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidCapacity& _s)
{
  CF::Device::InvalidCapacity* _p = new CF::Device::InvalidCapacity(_s);
  _a.PR_insert(_0RL_tc_CF_mDevice_mInvalidCapacity,
               _0RL_CF_mDevice_mInvalidCapacity_marshal_fn,
               _0RL_CF_mDevice_mInvalidCapacity_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidCapacity* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDevice_mInvalidCapacity,
               _0RL_CF_mDevice_mInvalidCapacity_marshal_fn,
               _0RL_CF_mDevice_mInvalidCapacity_destructor_fn,
               (CF::Device::InvalidCapacity*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Device::InvalidCapacity*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDevice_mInvalidCapacity,
                    _0RL_CF_mDevice_mInvalidCapacity_unmarshal_fn,
                    _0RL_CF_mDevice_mInvalidCapacity_marshal_fn,
                    _0RL_CF_mDevice_mInvalidCapacity_destructor_fn,
                    _v)) {
    _sp = (const CF::Device::InvalidCapacity*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mDevice_mInvalidCapacity(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::Device::InvalidCapacity & _ex = (const CF::Device::InvalidCapacity &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mDevice_mInvalidCapacity (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::Device::InvalidCapacity* _ex = (const CF::Device::InvalidCapacity*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mDevice_mInvalidCapacity {
public:
  _0RL_insertToAny_Singleton__cCF_mDevice_mInvalidCapacity() {
    CF::Device::InvalidCapacity::insertToAnyFn = _0RL_insertToAny__cCF_mDevice_mInvalidCapacity;
    CF::Device::InvalidCapacity::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mDevice_mInvalidCapacity;
  }
};
static _0RL_insertToAny_Singleton__cCF_mDevice_mInvalidCapacity _0RL_insertToAny_Singleton__cCF_mDevice_mInvalidCapacity_;

static void _0RL_CF_mDevice_mAdminType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::Device::AdminType* _p = (CF::Device::AdminType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDevice_mAdminType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Device::AdminType* _p = (CF::Device::AdminType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CF::Device::AdminType _s)
{
  _a.PR_insert(_0RL_tc_CF_mDevice_mAdminType,
               _0RL_CF_mDevice_mAdminType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::AdminType& _s)
{
  return _a.PR_extract(_0RL_tc_CF_mDevice_mAdminType,
                       _0RL_CF_mDevice_mAdminType_unmarshal_fn,
                       &_s);
}

static void _0RL_CF_mDevice_mOperationalType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::Device::OperationalType* _p = (CF::Device::OperationalType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDevice_mOperationalType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Device::OperationalType* _p = (CF::Device::OperationalType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CF::Device::OperationalType _s)
{
  _a.PR_insert(_0RL_tc_CF_mDevice_mOperationalType,
               _0RL_CF_mDevice_mOperationalType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::OperationalType& _s)
{
  return _a.PR_extract(_0RL_tc_CF_mDevice_mOperationalType,
                       _0RL_CF_mDevice_mOperationalType_unmarshal_fn,
                       &_s);
}

static void _0RL_CF_mDevice_mUsageType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::Device::UsageType* _p = (CF::Device::UsageType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDevice_mUsageType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Device::UsageType* _p = (CF::Device::UsageType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CF::Device::UsageType _s)
{
  _a.PR_insert(_0RL_tc_CF_mDevice_mUsageType,
               _0RL_CF_mDevice_mUsageType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::UsageType& _s)
{
  return _a.PR_extract(_0RL_tc_CF_mDevice_mUsageType,
                       _0RL_CF_mDevice_mUsageType_unmarshal_fn,
                       &_s);
}

static void _0RL_CF_mDevice_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mDevice_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::Device::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mDevice_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::Device_ptr _o)
{
  CF::Device_ptr _no = CF::Device::_duplicate(_o);
  _a.PR_insert(CF::_tc_Device,
               _0RL_CF_mDevice_marshal_fn,
               _0RL_CF_mDevice_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::Device_ptr* _op)
{
  _a.PR_insert(CF::_tc_Device,
               _0RL_CF_mDevice_marshal_fn,
               _0RL_CF_mDevice_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::Device::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Device_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_Device,
                    _0RL_CF_mDevice_unmarshal_fn,
                    _0RL_CF_mDevice_marshal_fn,
                    _0RL_CF_mDevice_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::Device_ptr)_r->_ptrToObjRef(CF::Device::_PD_repoId);
    else
      _o = CF::Device::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CF_mApplication_mComponentProcessIdType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::Application::ComponentProcessIdType* _p = (CF::Application::ComponentProcessIdType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mApplication_mComponentProcessIdType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Application::ComponentProcessIdType* _p = new CF::Application::ComponentProcessIdType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mApplication_mComponentProcessIdType_destructor_fn(void* _v)
{
  CF::Application::ComponentProcessIdType* _p = (CF::Application::ComponentProcessIdType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentProcessIdType& _s)
{
  CF::Application::ComponentProcessIdType* _p = new CF::Application::ComponentProcessIdType(_s);
  _a.PR_insert(_0RL_tc_CF_mApplication_mComponentProcessIdType,
               _0RL_CF_mApplication_mComponentProcessIdType_marshal_fn,
               _0RL_CF_mApplication_mComponentProcessIdType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::Application::ComponentProcessIdType* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mApplication_mComponentProcessIdType,
               _0RL_CF_mApplication_mComponentProcessIdType_marshal_fn,
               _0RL_CF_mApplication_mComponentProcessIdType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentProcessIdType*& _sp)
{
  return _a >>= (const CF::Application::ComponentProcessIdType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentProcessIdType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mApplication_mComponentProcessIdType,
                    _0RL_CF_mApplication_mComponentProcessIdType_unmarshal_fn,
                    _0RL_CF_mApplication_mComponentProcessIdType_marshal_fn,
                    _0RL_CF_mApplication_mComponentProcessIdType_destructor_fn,
                    _v)) {
    _sp = (const CF::Application::ComponentProcessIdType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mApplication_mComponentProcessIdSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::Application::ComponentProcessIdSequence* _p = (CF::Application::ComponentProcessIdSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mApplication_mComponentProcessIdSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Application::ComponentProcessIdSequence* _p = new CF::Application::ComponentProcessIdSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mApplication_mComponentProcessIdSequence_destructor_fn(void* _v)
{
  CF::Application::ComponentProcessIdSequence* _p = (CF::Application::ComponentProcessIdSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentProcessIdSequence& _s)
{
  CF::Application::ComponentProcessIdSequence* _p = new CF::Application::ComponentProcessIdSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mApplication_mComponentProcessIdSequence,
               _0RL_CF_mApplication_mComponentProcessIdSequence_marshal_fn,
               _0RL_CF_mApplication_mComponentProcessIdSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::Application::ComponentProcessIdSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mApplication_mComponentProcessIdSequence,
               _0RL_CF_mApplication_mComponentProcessIdSequence_marshal_fn,
               _0RL_CF_mApplication_mComponentProcessIdSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentProcessIdSequence*& _sp)
{
  return _a >>= (const CF::Application::ComponentProcessIdSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentProcessIdSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mApplication_mComponentProcessIdSequence,
                    _0RL_CF_mApplication_mComponentProcessIdSequence_unmarshal_fn,
                    _0RL_CF_mApplication_mComponentProcessIdSequence_marshal_fn,
                    _0RL_CF_mApplication_mComponentProcessIdSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::Application::ComponentProcessIdSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mApplication_mComponentElementType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::Application::ComponentElementType* _p = (CF::Application::ComponentElementType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mApplication_mComponentElementType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Application::ComponentElementType* _p = new CF::Application::ComponentElementType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mApplication_mComponentElementType_destructor_fn(void* _v)
{
  CF::Application::ComponentElementType* _p = (CF::Application::ComponentElementType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentElementType& _s)
{
  CF::Application::ComponentElementType* _p = new CF::Application::ComponentElementType(_s);
  _a.PR_insert(_0RL_tc_CF_mApplication_mComponentElementType,
               _0RL_CF_mApplication_mComponentElementType_marshal_fn,
               _0RL_CF_mApplication_mComponentElementType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::Application::ComponentElementType* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mApplication_mComponentElementType,
               _0RL_CF_mApplication_mComponentElementType_marshal_fn,
               _0RL_CF_mApplication_mComponentElementType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentElementType*& _sp)
{
  return _a >>= (const CF::Application::ComponentElementType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentElementType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mApplication_mComponentElementType,
                    _0RL_CF_mApplication_mComponentElementType_unmarshal_fn,
                    _0RL_CF_mApplication_mComponentElementType_marshal_fn,
                    _0RL_CF_mApplication_mComponentElementType_destructor_fn,
                    _v)) {
    _sp = (const CF::Application::ComponentElementType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mApplication_mComponentElementSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::Application::ComponentElementSequence* _p = (CF::Application::ComponentElementSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mApplication_mComponentElementSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::Application::ComponentElementSequence* _p = new CF::Application::ComponentElementSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mApplication_mComponentElementSequence_destructor_fn(void* _v)
{
  CF::Application::ComponentElementSequence* _p = (CF::Application::ComponentElementSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentElementSequence& _s)
{
  CF::Application::ComponentElementSequence* _p = new CF::Application::ComponentElementSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mApplication_mComponentElementSequence,
               _0RL_CF_mApplication_mComponentElementSequence_marshal_fn,
               _0RL_CF_mApplication_mComponentElementSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::Application::ComponentElementSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mApplication_mComponentElementSequence,
               _0RL_CF_mApplication_mComponentElementSequence_marshal_fn,
               _0RL_CF_mApplication_mComponentElementSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentElementSequence*& _sp)
{
  return _a >>= (const CF::Application::ComponentElementSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentElementSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mApplication_mComponentElementSequence,
                    _0RL_CF_mApplication_mComponentElementSequence_unmarshal_fn,
                    _0RL_CF_mApplication_mComponentElementSequence_marshal_fn,
                    _0RL_CF_mApplication_mComponentElementSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::Application::ComponentElementSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mApplication_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mApplication_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::Application::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mApplication_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::Application_ptr _o)
{
  CF::Application_ptr _no = CF::Application::_duplicate(_o);
  _a.PR_insert(CF::_tc_Application,
               _0RL_CF_mApplication_marshal_fn,
               _0RL_CF_mApplication_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::Application_ptr* _op)
{
  _a.PR_insert(CF::_tc_Application,
               _0RL_CF_mApplication_marshal_fn,
               _0RL_CF_mApplication_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::Application::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::Application_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_Application,
                    _0RL_CF_mApplication_unmarshal_fn,
                    _0RL_CF_mApplication_marshal_fn,
                    _0RL_CF_mApplication_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::Application_ptr)_r->_ptrToObjRef(CF::Application::_PD_repoId);
    else
      _o = CF::Application::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CF_mLoadableDevice_mLoadType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::LoadableDevice::LoadType* _p = (CF::LoadableDevice::LoadType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mLoadableDevice_mLoadType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::LoadableDevice::LoadType* _p = (CF::LoadableDevice::LoadType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, CF::LoadableDevice::LoadType _s)
{
  _a.PR_insert(_0RL_tc_CF_mLoadableDevice_mLoadType,
               _0RL_CF_mLoadableDevice_mLoadType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::LoadableDevice::LoadType& _s)
{
  return _a.PR_extract(_0RL_tc_CF_mLoadableDevice_mLoadType,
                       _0RL_CF_mLoadableDevice_mLoadType_unmarshal_fn,
                       &_s);
}


static void _0RL_CF_mLoadableDevice_mInvalidLoadKind_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::LoadableDevice::InvalidLoadKind* _p = (const CF::LoadableDevice::InvalidLoadKind*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mLoadableDevice_mInvalidLoadKind_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::LoadableDevice::InvalidLoadKind* _p = new CF::LoadableDevice::InvalidLoadKind;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mLoadableDevice_mInvalidLoadKind_destructor_fn(void* _v)
{
  CF::LoadableDevice::InvalidLoadKind* _p = (CF::LoadableDevice::InvalidLoadKind*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind& _s)
{
  CF::LoadableDevice::InvalidLoadKind* _p = new CF::LoadableDevice::InvalidLoadKind(_s);
  _a.PR_insert(_0RL_tc_CF_mLoadableDevice_mInvalidLoadKind,
               _0RL_CF_mLoadableDevice_mInvalidLoadKind_marshal_fn,
               _0RL_CF_mLoadableDevice_mInvalidLoadKind_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mLoadableDevice_mInvalidLoadKind,
               _0RL_CF_mLoadableDevice_mInvalidLoadKind_marshal_fn,
               _0RL_CF_mLoadableDevice_mInvalidLoadKind_destructor_fn,
               (CF::LoadableDevice::InvalidLoadKind*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mLoadableDevice_mInvalidLoadKind,
                    _0RL_CF_mLoadableDevice_mInvalidLoadKind_unmarshal_fn,
                    _0RL_CF_mLoadableDevice_mInvalidLoadKind_marshal_fn,
                    _0RL_CF_mLoadableDevice_mInvalidLoadKind_destructor_fn,
                    _v)) {
    _sp = (const CF::LoadableDevice::InvalidLoadKind*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mLoadableDevice_mInvalidLoadKind(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::LoadableDevice::InvalidLoadKind & _ex = (const CF::LoadableDevice::InvalidLoadKind &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mLoadableDevice_mInvalidLoadKind (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::LoadableDevice::InvalidLoadKind* _ex = (const CF::LoadableDevice::InvalidLoadKind*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mLoadableDevice_mInvalidLoadKind {
public:
  _0RL_insertToAny_Singleton__cCF_mLoadableDevice_mInvalidLoadKind() {
    CF::LoadableDevice::InvalidLoadKind::insertToAnyFn = _0RL_insertToAny__cCF_mLoadableDevice_mInvalidLoadKind;
    CF::LoadableDevice::InvalidLoadKind::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mLoadableDevice_mInvalidLoadKind;
  }
};
static _0RL_insertToAny_Singleton__cCF_mLoadableDevice_mInvalidLoadKind _0RL_insertToAny_Singleton__cCF_mLoadableDevice_mInvalidLoadKind_;


static void _0RL_CF_mLoadableDevice_mLoadFail_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::LoadableDevice::LoadFail* _p = (const CF::LoadableDevice::LoadFail*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mLoadableDevice_mLoadFail_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::LoadableDevice::LoadFail* _p = new CF::LoadableDevice::LoadFail;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mLoadableDevice_mLoadFail_destructor_fn(void* _v)
{
  CF::LoadableDevice::LoadFail* _p = (CF::LoadableDevice::LoadFail*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::LoadFail& _s)
{
  CF::LoadableDevice::LoadFail* _p = new CF::LoadableDevice::LoadFail(_s);
  _a.PR_insert(_0RL_tc_CF_mLoadableDevice_mLoadFail,
               _0RL_CF_mLoadableDevice_mLoadFail_marshal_fn,
               _0RL_CF_mLoadableDevice_mLoadFail_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::LoadFail* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mLoadableDevice_mLoadFail,
               _0RL_CF_mLoadableDevice_mLoadFail_marshal_fn,
               _0RL_CF_mLoadableDevice_mLoadFail_destructor_fn,
               (CF::LoadableDevice::LoadFail*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::LoadableDevice::LoadFail*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mLoadableDevice_mLoadFail,
                    _0RL_CF_mLoadableDevice_mLoadFail_unmarshal_fn,
                    _0RL_CF_mLoadableDevice_mLoadFail_marshal_fn,
                    _0RL_CF_mLoadableDevice_mLoadFail_destructor_fn,
                    _v)) {
    _sp = (const CF::LoadableDevice::LoadFail*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mLoadableDevice_mLoadFail(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::LoadableDevice::LoadFail & _ex = (const CF::LoadableDevice::LoadFail &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mLoadableDevice_mLoadFail (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::LoadableDevice::LoadFail* _ex = (const CF::LoadableDevice::LoadFail*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mLoadableDevice_mLoadFail {
public:
  _0RL_insertToAny_Singleton__cCF_mLoadableDevice_mLoadFail() {
    CF::LoadableDevice::LoadFail::insertToAnyFn = _0RL_insertToAny__cCF_mLoadableDevice_mLoadFail;
    CF::LoadableDevice::LoadFail::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mLoadableDevice_mLoadFail;
  }
};
static _0RL_insertToAny_Singleton__cCF_mLoadableDevice_mLoadFail _0RL_insertToAny_Singleton__cCF_mLoadableDevice_mLoadFail_;

static void _0RL_CF_mLoadableDevice_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mLoadableDevice_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::LoadableDevice::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mLoadableDevice_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::LoadableDevice_ptr _o)
{
  CF::LoadableDevice_ptr _no = CF::LoadableDevice::_duplicate(_o);
  _a.PR_insert(CF::_tc_LoadableDevice,
               _0RL_CF_mLoadableDevice_marshal_fn,
               _0RL_CF_mLoadableDevice_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::LoadableDevice_ptr* _op)
{
  _a.PR_insert(CF::_tc_LoadableDevice,
               _0RL_CF_mLoadableDevice_marshal_fn,
               _0RL_CF_mLoadableDevice_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::LoadableDevice::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::LoadableDevice_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_LoadableDevice,
                    _0RL_CF_mLoadableDevice_unmarshal_fn,
                    _0RL_CF_mLoadableDevice_marshal_fn,
                    _0RL_CF_mLoadableDevice_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::LoadableDevice_ptr)_r->_ptrToObjRef(CF::LoadableDevice::_PD_repoId);
    else
      _o = CF::LoadableDevice::_nil();
    return 1;
  }
  return 0;
}


static void _0RL_CF_mExecutableDevice_mInvalidProcess_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ExecutableDevice::InvalidProcess* _p = (const CF::ExecutableDevice::InvalidProcess*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mExecutableDevice_mInvalidProcess_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ExecutableDevice::InvalidProcess* _p = new CF::ExecutableDevice::InvalidProcess;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mExecutableDevice_mInvalidProcess_destructor_fn(void* _v)
{
  CF::ExecutableDevice::InvalidProcess* _p = (CF::ExecutableDevice::InvalidProcess*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess& _s)
{
  CF::ExecutableDevice::InvalidProcess* _p = new CF::ExecutableDevice::InvalidProcess(_s);
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mInvalidProcess,
               _0RL_CF_mExecutableDevice_mInvalidProcess_marshal_fn,
               _0RL_CF_mExecutableDevice_mInvalidProcess_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mInvalidProcess,
               _0RL_CF_mExecutableDevice_mInvalidProcess_marshal_fn,
               _0RL_CF_mExecutableDevice_mInvalidProcess_destructor_fn,
               (CF::ExecutableDevice::InvalidProcess*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mExecutableDevice_mInvalidProcess,
                    _0RL_CF_mExecutableDevice_mInvalidProcess_unmarshal_fn,
                    _0RL_CF_mExecutableDevice_mInvalidProcess_marshal_fn,
                    _0RL_CF_mExecutableDevice_mInvalidProcess_destructor_fn,
                    _v)) {
    _sp = (const CF::ExecutableDevice::InvalidProcess*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mExecutableDevice_mInvalidProcess(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ExecutableDevice::InvalidProcess & _ex = (const CF::ExecutableDevice::InvalidProcess &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mExecutableDevice_mInvalidProcess (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ExecutableDevice::InvalidProcess* _ex = (const CF::ExecutableDevice::InvalidProcess*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidProcess {
public:
  _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidProcess() {
    CF::ExecutableDevice::InvalidProcess::insertToAnyFn = _0RL_insertToAny__cCF_mExecutableDevice_mInvalidProcess;
    CF::ExecutableDevice::InvalidProcess::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mExecutableDevice_mInvalidProcess;
  }
};
static _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidProcess _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidProcess_;


static void _0RL_CF_mExecutableDevice_mInvalidFunction_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ExecutableDevice::InvalidFunction* _p = (const CF::ExecutableDevice::InvalidFunction*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mExecutableDevice_mInvalidFunction_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ExecutableDevice::InvalidFunction* _p = new CF::ExecutableDevice::InvalidFunction;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mExecutableDevice_mInvalidFunction_destructor_fn(void* _v)
{
  CF::ExecutableDevice::InvalidFunction* _p = (CF::ExecutableDevice::InvalidFunction*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction& _s)
{
  CF::ExecutableDevice::InvalidFunction* _p = new CF::ExecutableDevice::InvalidFunction(_s);
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mInvalidFunction,
               _0RL_CF_mExecutableDevice_mInvalidFunction_marshal_fn,
               _0RL_CF_mExecutableDevice_mInvalidFunction_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mInvalidFunction,
               _0RL_CF_mExecutableDevice_mInvalidFunction_marshal_fn,
               _0RL_CF_mExecutableDevice_mInvalidFunction_destructor_fn,
               (CF::ExecutableDevice::InvalidFunction*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mExecutableDevice_mInvalidFunction,
                    _0RL_CF_mExecutableDevice_mInvalidFunction_unmarshal_fn,
                    _0RL_CF_mExecutableDevice_mInvalidFunction_marshal_fn,
                    _0RL_CF_mExecutableDevice_mInvalidFunction_destructor_fn,
                    _v)) {
    _sp = (const CF::ExecutableDevice::InvalidFunction*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mExecutableDevice_mInvalidFunction(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ExecutableDevice::InvalidFunction & _ex = (const CF::ExecutableDevice::InvalidFunction &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mExecutableDevice_mInvalidFunction (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ExecutableDevice::InvalidFunction* _ex = (const CF::ExecutableDevice::InvalidFunction*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidFunction {
public:
  _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidFunction() {
    CF::ExecutableDevice::InvalidFunction::insertToAnyFn = _0RL_insertToAny__cCF_mExecutableDevice_mInvalidFunction;
    CF::ExecutableDevice::InvalidFunction::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mExecutableDevice_mInvalidFunction;
  }
};
static _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidFunction _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidFunction_;


static void _0RL_CF_mExecutableDevice_mInvalidParameters_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ExecutableDevice::InvalidParameters* _p = (const CF::ExecutableDevice::InvalidParameters*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mExecutableDevice_mInvalidParameters_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ExecutableDevice::InvalidParameters* _p = new CF::ExecutableDevice::InvalidParameters;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mExecutableDevice_mInvalidParameters_destructor_fn(void* _v)
{
  CF::ExecutableDevice::InvalidParameters* _p = (CF::ExecutableDevice::InvalidParameters*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters& _s)
{
  CF::ExecutableDevice::InvalidParameters* _p = new CF::ExecutableDevice::InvalidParameters(_s);
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mInvalidParameters,
               _0RL_CF_mExecutableDevice_mInvalidParameters_marshal_fn,
               _0RL_CF_mExecutableDevice_mInvalidParameters_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mInvalidParameters,
               _0RL_CF_mExecutableDevice_mInvalidParameters_marshal_fn,
               _0RL_CF_mExecutableDevice_mInvalidParameters_destructor_fn,
               (CF::ExecutableDevice::InvalidParameters*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mExecutableDevice_mInvalidParameters,
                    _0RL_CF_mExecutableDevice_mInvalidParameters_unmarshal_fn,
                    _0RL_CF_mExecutableDevice_mInvalidParameters_marshal_fn,
                    _0RL_CF_mExecutableDevice_mInvalidParameters_destructor_fn,
                    _v)) {
    _sp = (const CF::ExecutableDevice::InvalidParameters*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mExecutableDevice_mInvalidParameters(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ExecutableDevice::InvalidParameters & _ex = (const CF::ExecutableDevice::InvalidParameters &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mExecutableDevice_mInvalidParameters (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ExecutableDevice::InvalidParameters* _ex = (const CF::ExecutableDevice::InvalidParameters*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidParameters {
public:
  _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidParameters() {
    CF::ExecutableDevice::InvalidParameters::insertToAnyFn = _0RL_insertToAny__cCF_mExecutableDevice_mInvalidParameters;
    CF::ExecutableDevice::InvalidParameters::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mExecutableDevice_mInvalidParameters;
  }
};
static _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidParameters _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidParameters_;


static void _0RL_CF_mExecutableDevice_mInvalidOptions_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ExecutableDevice::InvalidOptions* _p = (const CF::ExecutableDevice::InvalidOptions*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mExecutableDevice_mInvalidOptions_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ExecutableDevice::InvalidOptions* _p = new CF::ExecutableDevice::InvalidOptions;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mExecutableDevice_mInvalidOptions_destructor_fn(void* _v)
{
  CF::ExecutableDevice::InvalidOptions* _p = (CF::ExecutableDevice::InvalidOptions*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions& _s)
{
  CF::ExecutableDevice::InvalidOptions* _p = new CF::ExecutableDevice::InvalidOptions(_s);
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mInvalidOptions,
               _0RL_CF_mExecutableDevice_mInvalidOptions_marshal_fn,
               _0RL_CF_mExecutableDevice_mInvalidOptions_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mInvalidOptions,
               _0RL_CF_mExecutableDevice_mInvalidOptions_marshal_fn,
               _0RL_CF_mExecutableDevice_mInvalidOptions_destructor_fn,
               (CF::ExecutableDevice::InvalidOptions*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mExecutableDevice_mInvalidOptions,
                    _0RL_CF_mExecutableDevice_mInvalidOptions_unmarshal_fn,
                    _0RL_CF_mExecutableDevice_mInvalidOptions_marshal_fn,
                    _0RL_CF_mExecutableDevice_mInvalidOptions_destructor_fn,
                    _v)) {
    _sp = (const CF::ExecutableDevice::InvalidOptions*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mExecutableDevice_mInvalidOptions(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ExecutableDevice::InvalidOptions & _ex = (const CF::ExecutableDevice::InvalidOptions &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mExecutableDevice_mInvalidOptions (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ExecutableDevice::InvalidOptions* _ex = (const CF::ExecutableDevice::InvalidOptions*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidOptions {
public:
  _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidOptions() {
    CF::ExecutableDevice::InvalidOptions::insertToAnyFn = _0RL_insertToAny__cCF_mExecutableDevice_mInvalidOptions;
    CF::ExecutableDevice::InvalidOptions::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mExecutableDevice_mInvalidOptions;
  }
};
static _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidOptions _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mInvalidOptions_;


static void _0RL_CF_mExecutableDevice_mExecuteFail_marshal_fn(cdrStream& _s, void* _v)
{
  const CF::ExecutableDevice::ExecuteFail* _p = (const CF::ExecutableDevice::ExecuteFail*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mExecutableDevice_mExecuteFail_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::ExecutableDevice::ExecuteFail* _p = new CF::ExecutableDevice::ExecuteFail;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mExecutableDevice_mExecuteFail_destructor_fn(void* _v)
{
  CF::ExecutableDevice::ExecuteFail* _p = (CF::ExecutableDevice::ExecuteFail*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail& _s)
{
  CF::ExecutableDevice::ExecuteFail* _p = new CF::ExecutableDevice::ExecuteFail(_s);
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mExecuteFail,
               _0RL_CF_mExecutableDevice_mExecuteFail_marshal_fn,
               _0RL_CF_mExecutableDevice_mExecuteFail_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mExecutableDevice_mExecuteFail,
               _0RL_CF_mExecutableDevice_mExecuteFail_marshal_fn,
               _0RL_CF_mExecutableDevice_mExecuteFail_destructor_fn,
               (CF::ExecutableDevice::ExecuteFail*)_sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mExecutableDevice_mExecuteFail,
                    _0RL_CF_mExecutableDevice_mExecuteFail_unmarshal_fn,
                    _0RL_CF_mExecutableDevice_mExecuteFail_marshal_fn,
                    _0RL_CF_mExecutableDevice_mExecuteFail_destructor_fn,
                    _v)) {
    _sp = (const CF::ExecutableDevice::ExecuteFail*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_insertToAny__cCF_mExecutableDevice_mExecuteFail(::CORBA::Any& _a, const ::CORBA::Exception& _e) {
  const CF::ExecutableDevice::ExecuteFail & _ex = (const CF::ExecutableDevice::ExecuteFail &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCF_mExecutableDevice_mExecuteFail (::CORBA::Any& _a, const ::CORBA::Exception* _e) {
  const CF::ExecutableDevice::ExecuteFail* _ex = (const CF::ExecutableDevice::ExecuteFail*) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mExecuteFail {
public:
  _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mExecuteFail() {
    CF::ExecutableDevice::ExecuteFail::insertToAnyFn = _0RL_insertToAny__cCF_mExecutableDevice_mExecuteFail;
    CF::ExecutableDevice::ExecuteFail::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCF_mExecutableDevice_mExecuteFail;
  }
};
static _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mExecuteFail _0RL_insertToAny_Singleton__cCF_mExecutableDevice_mExecuteFail_;

static void _0RL_CF_mExecutableDevice_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mExecutableDevice_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::ExecutableDevice::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mExecutableDevice_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::ExecutableDevice_ptr _o)
{
  CF::ExecutableDevice_ptr _no = CF::ExecutableDevice::_duplicate(_o);
  _a.PR_insert(CF::_tc_ExecutableDevice,
               _0RL_CF_mExecutableDevice_marshal_fn,
               _0RL_CF_mExecutableDevice_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::ExecutableDevice_ptr* _op)
{
  _a.PR_insert(CF::_tc_ExecutableDevice,
               _0RL_CF_mExecutableDevice_marshal_fn,
               _0RL_CF_mExecutableDevice_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::ExecutableDevice::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::ExecutableDevice_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_ExecutableDevice,
                    _0RL_CF_mExecutableDevice_unmarshal_fn,
                    _0RL_CF_mExecutableDevice_marshal_fn,
                    _0RL_CF_mExecutableDevice_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::ExecutableDevice_ptr)_r->_ptrToObjRef(CF::ExecutableDevice::_PD_repoId);
    else
      _o = CF::ExecutableDevice::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_CF_mDeviceManager_mServiceType_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DeviceManager::ServiceType* _p = (CF::DeviceManager::ServiceType*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDeviceManager_mServiceType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DeviceManager::ServiceType* _p = new CF::DeviceManager::ServiceType;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDeviceManager_mServiceType_destructor_fn(void* _v)
{
  CF::DeviceManager::ServiceType* _p = (CF::DeviceManager::ServiceType*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DeviceManager::ServiceType& _s)
{
  CF::DeviceManager::ServiceType* _p = new CF::DeviceManager::ServiceType(_s);
  _a.PR_insert(_0RL_tc_CF_mDeviceManager_mServiceType,
               _0RL_CF_mDeviceManager_mServiceType_marshal_fn,
               _0RL_CF_mDeviceManager_mServiceType_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DeviceManager::ServiceType* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDeviceManager_mServiceType,
               _0RL_CF_mDeviceManager_mServiceType_marshal_fn,
               _0RL_CF_mDeviceManager_mServiceType_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager::ServiceType*& _sp)
{
  return _a >>= (const CF::DeviceManager::ServiceType*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceManager::ServiceType*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDeviceManager_mServiceType,
                    _0RL_CF_mDeviceManager_mServiceType_unmarshal_fn,
                    _0RL_CF_mDeviceManager_mServiceType_marshal_fn,
                    _0RL_CF_mDeviceManager_mServiceType_destructor_fn,
                    _v)) {
    _sp = (const CF::DeviceManager::ServiceType*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mDeviceManager_mServiceSequence_marshal_fn(cdrStream& _s, void* _v)
{
  CF::DeviceManager::ServiceSequence* _p = (CF::DeviceManager::ServiceSequence*)_v;
  *_p >>= _s;
}
static void _0RL_CF_mDeviceManager_mServiceSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  CF::DeviceManager::ServiceSequence* _p = new CF::DeviceManager::ServiceSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_CF_mDeviceManager_mServiceSequence_destructor_fn(void* _v)
{
  CF::DeviceManager::ServiceSequence* _p = (CF::DeviceManager::ServiceSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const CF::DeviceManager::ServiceSequence& _s)
{
  CF::DeviceManager::ServiceSequence* _p = new CF::DeviceManager::ServiceSequence(_s);
  _a.PR_insert(_0RL_tc_CF_mDeviceManager_mServiceSequence,
               _0RL_CF_mDeviceManager_mServiceSequence_marshal_fn,
               _0RL_CF_mDeviceManager_mServiceSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, CF::DeviceManager::ServiceSequence* _sp)
{
  _a.PR_insert(_0RL_tc_CF_mDeviceManager_mServiceSequence,
               _0RL_CF_mDeviceManager_mServiceSequence_marshal_fn,
               _0RL_CF_mDeviceManager_mServiceSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager::ServiceSequence*& _sp)
{
  return _a >>= (const CF::DeviceManager::ServiceSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceManager::ServiceSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_CF_mDeviceManager_mServiceSequence,
                    _0RL_CF_mDeviceManager_mServiceSequence_unmarshal_fn,
                    _0RL_CF_mDeviceManager_mServiceSequence_marshal_fn,
                    _0RL_CF_mDeviceManager_mServiceSequence_destructor_fn,
                    _v)) {
    _sp = (const CF::DeviceManager::ServiceSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_CF_mDeviceManager_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_CF_mDeviceManager_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(CF::DeviceManager::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_CF_mDeviceManager_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, CF::DeviceManager_ptr _o)
{
  CF::DeviceManager_ptr _no = CF::DeviceManager::_duplicate(_o);
  _a.PR_insert(CF::_tc_DeviceManager,
               _0RL_CF_mDeviceManager_marshal_fn,
               _0RL_CF_mDeviceManager_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, CF::DeviceManager_ptr* _op)
{
  _a.PR_insert(CF::_tc_DeviceManager,
               _0RL_CF_mDeviceManager_marshal_fn,
               _0RL_CF_mDeviceManager_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = CF::DeviceManager::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(CF::_tc_DeviceManager,
                    _0RL_CF_mDeviceManager_unmarshal_fn,
                    _0RL_CF_mDeviceManager_marshal_fn,
                    _0RL_CF_mDeviceManager_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (CF::DeviceManager_ptr)_r->_ptrToObjRef(CF::DeviceManager::_PD_repoId);
    else
      _o = CF::DeviceManager::_nil();
    return 1;
  }
  return 0;
}

