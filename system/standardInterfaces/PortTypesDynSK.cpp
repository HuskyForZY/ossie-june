// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "PortTypes.h"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mWstringSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/WstringSequence:1.0", "WstringSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_wstring_tc(0, &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_WstringSequence = _0RL_tc_PortTypes_mWstringSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_WstringSequence = _0RL_tc_PortTypes_mWstringSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mBooleanSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/BooleanSequence:1.0", "BooleanSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_boolean_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_BooleanSequence = _0RL_tc_PortTypes_mBooleanSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_BooleanSequence = _0RL_tc_PortTypes_mBooleanSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mCharSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/CharSequence:1.0", "CharSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_char_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_CharSequence = _0RL_tc_PortTypes_mCharSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_CharSequence = _0RL_tc_PortTypes_mCharSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mDoubleSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/DoubleSequence:1.0", "DoubleSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_DoubleSequence = _0RL_tc_PortTypes_mDoubleSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_DoubleSequence = _0RL_tc_PortTypes_mDoubleSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mLongSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/LongSequence:1.0", "LongSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_LongSequence = _0RL_tc_PortTypes_mLongSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_LongSequence = _0RL_tc_PortTypes_mLongSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mShortSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/ShortSequence:1.0", "ShortSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_short_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_ShortSequence = _0RL_tc_PortTypes_mShortSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_ShortSequence = _0RL_tc_PortTypes_mShortSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mUlongLongSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/UlongLongSequence:1.0", "UlongLongSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ulonglong_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_UlongLongSequence = _0RL_tc_PortTypes_mUlongLongSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_UlongLongSequence = _0RL_tc_PortTypes_mUlongLongSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mUlongSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/UlongSequence:1.0", "UlongSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ulong_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_UlongSequence = _0RL_tc_PortTypes_mUlongSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_UlongSequence = _0RL_tc_PortTypes_mUlongSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mUshortSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/UshortSequence:1.0", "UshortSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_ushort_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_UshortSequence = _0RL_tc_PortTypes_mUshortSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_UshortSequence = _0RL_tc_PortTypes_mUshortSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mWcharSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/WcharSequence:1.0", "WcharSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_wchar_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_WcharSequence = _0RL_tc_PortTypes_mWcharSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_WcharSequence = _0RL_tc_PortTypes_mWcharSequence;
#endif

static CORBA::TypeCode_ptr _0RL_tc_PortTypes_mFloatSequence = CORBA::TypeCode::PR_alias_tc("IDL:PortTypes/FloatSequence:1.0", "FloatSequence", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_float_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace PortTypes { 
  const ::CORBA::TypeCode_ptr _tc_FloatSequence = _0RL_tc_PortTypes_mFloatSequence;
} 
#else
const ::CORBA::TypeCode_ptr PortTypes::_tc_FloatSequence = _0RL_tc_PortTypes_mFloatSequence;
#endif

static void _0RL_PortTypes_mWstringSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::WstringSequence* _p = (PortTypes::WstringSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mWstringSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::WstringSequence* _p = new PortTypes::WstringSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mWstringSequence_destructor_fn(void* _v)
{
  PortTypes::WstringSequence* _p = (PortTypes::WstringSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::WstringSequence& _s)
{
  PortTypes::WstringSequence* _p = new PortTypes::WstringSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mWstringSequence,
               _0RL_PortTypes_mWstringSequence_marshal_fn,
               _0RL_PortTypes_mWstringSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::WstringSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mWstringSequence,
               _0RL_PortTypes_mWstringSequence_marshal_fn,
               _0RL_PortTypes_mWstringSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::WstringSequence*& _sp)
{
  return _a >>= (const PortTypes::WstringSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::WstringSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mWstringSequence,
                    _0RL_PortTypes_mWstringSequence_unmarshal_fn,
                    _0RL_PortTypes_mWstringSequence_marshal_fn,
                    _0RL_PortTypes_mWstringSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::WstringSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mBooleanSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::BooleanSequence* _p = (PortTypes::BooleanSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mBooleanSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::BooleanSequence* _p = new PortTypes::BooleanSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mBooleanSequence_destructor_fn(void* _v)
{
  PortTypes::BooleanSequence* _p = (PortTypes::BooleanSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::BooleanSequence& _s)
{
  PortTypes::BooleanSequence* _p = new PortTypes::BooleanSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mBooleanSequence,
               _0RL_PortTypes_mBooleanSequence_marshal_fn,
               _0RL_PortTypes_mBooleanSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::BooleanSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mBooleanSequence,
               _0RL_PortTypes_mBooleanSequence_marshal_fn,
               _0RL_PortTypes_mBooleanSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::BooleanSequence*& _sp)
{
  return _a >>= (const PortTypes::BooleanSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::BooleanSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mBooleanSequence,
                    _0RL_PortTypes_mBooleanSequence_unmarshal_fn,
                    _0RL_PortTypes_mBooleanSequence_marshal_fn,
                    _0RL_PortTypes_mBooleanSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::BooleanSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mCharSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::CharSequence* _p = (PortTypes::CharSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mCharSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::CharSequence* _p = new PortTypes::CharSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mCharSequence_destructor_fn(void* _v)
{
  PortTypes::CharSequence* _p = (PortTypes::CharSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::CharSequence& _s)
{
  PortTypes::CharSequence* _p = new PortTypes::CharSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mCharSequence,
               _0RL_PortTypes_mCharSequence_marshal_fn,
               _0RL_PortTypes_mCharSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::CharSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mCharSequence,
               _0RL_PortTypes_mCharSequence_marshal_fn,
               _0RL_PortTypes_mCharSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::CharSequence*& _sp)
{
  return _a >>= (const PortTypes::CharSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::CharSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mCharSequence,
                    _0RL_PortTypes_mCharSequence_unmarshal_fn,
                    _0RL_PortTypes_mCharSequence_marshal_fn,
                    _0RL_PortTypes_mCharSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::CharSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mDoubleSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::DoubleSequence* _p = (PortTypes::DoubleSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mDoubleSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::DoubleSequence* _p = new PortTypes::DoubleSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mDoubleSequence_destructor_fn(void* _v)
{
  PortTypes::DoubleSequence* _p = (PortTypes::DoubleSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::DoubleSequence& _s)
{
  PortTypes::DoubleSequence* _p = new PortTypes::DoubleSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mDoubleSequence,
               _0RL_PortTypes_mDoubleSequence_marshal_fn,
               _0RL_PortTypes_mDoubleSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::DoubleSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mDoubleSequence,
               _0RL_PortTypes_mDoubleSequence_marshal_fn,
               _0RL_PortTypes_mDoubleSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::DoubleSequence*& _sp)
{
  return _a >>= (const PortTypes::DoubleSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::DoubleSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mDoubleSequence,
                    _0RL_PortTypes_mDoubleSequence_unmarshal_fn,
                    _0RL_PortTypes_mDoubleSequence_marshal_fn,
                    _0RL_PortTypes_mDoubleSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::DoubleSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mLongSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::LongSequence* _p = (PortTypes::LongSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mLongSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::LongSequence* _p = new PortTypes::LongSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mLongSequence_destructor_fn(void* _v)
{
  PortTypes::LongSequence* _p = (PortTypes::LongSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::LongSequence& _s)
{
  PortTypes::LongSequence* _p = new PortTypes::LongSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mLongSequence,
               _0RL_PortTypes_mLongSequence_marshal_fn,
               _0RL_PortTypes_mLongSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::LongSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mLongSequence,
               _0RL_PortTypes_mLongSequence_marshal_fn,
               _0RL_PortTypes_mLongSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::LongSequence*& _sp)
{
  return _a >>= (const PortTypes::LongSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::LongSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mLongSequence,
                    _0RL_PortTypes_mLongSequence_unmarshal_fn,
                    _0RL_PortTypes_mLongSequence_marshal_fn,
                    _0RL_PortTypes_mLongSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::LongSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mShortSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::ShortSequence* _p = (PortTypes::ShortSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mShortSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::ShortSequence* _p = new PortTypes::ShortSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mShortSequence_destructor_fn(void* _v)
{
  PortTypes::ShortSequence* _p = (PortTypes::ShortSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::ShortSequence& _s)
{
  PortTypes::ShortSequence* _p = new PortTypes::ShortSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mShortSequence,
               _0RL_PortTypes_mShortSequence_marshal_fn,
               _0RL_PortTypes_mShortSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::ShortSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mShortSequence,
               _0RL_PortTypes_mShortSequence_marshal_fn,
               _0RL_PortTypes_mShortSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::ShortSequence*& _sp)
{
  return _a >>= (const PortTypes::ShortSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::ShortSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mShortSequence,
                    _0RL_PortTypes_mShortSequence_unmarshal_fn,
                    _0RL_PortTypes_mShortSequence_marshal_fn,
                    _0RL_PortTypes_mShortSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::ShortSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mUlongLongSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::UlongLongSequence* _p = (PortTypes::UlongLongSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mUlongLongSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::UlongLongSequence* _p = new PortTypes::UlongLongSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mUlongLongSequence_destructor_fn(void* _v)
{
  PortTypes::UlongLongSequence* _p = (PortTypes::UlongLongSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::UlongLongSequence& _s)
{
  PortTypes::UlongLongSequence* _p = new PortTypes::UlongLongSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mUlongLongSequence,
               _0RL_PortTypes_mUlongLongSequence_marshal_fn,
               _0RL_PortTypes_mUlongLongSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::UlongLongSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mUlongLongSequence,
               _0RL_PortTypes_mUlongLongSequence_marshal_fn,
               _0RL_PortTypes_mUlongLongSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UlongLongSequence*& _sp)
{
  return _a >>= (const PortTypes::UlongLongSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UlongLongSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mUlongLongSequence,
                    _0RL_PortTypes_mUlongLongSequence_unmarshal_fn,
                    _0RL_PortTypes_mUlongLongSequence_marshal_fn,
                    _0RL_PortTypes_mUlongLongSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::UlongLongSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mUlongSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::UlongSequence* _p = (PortTypes::UlongSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mUlongSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::UlongSequence* _p = new PortTypes::UlongSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mUlongSequence_destructor_fn(void* _v)
{
  PortTypes::UlongSequence* _p = (PortTypes::UlongSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::UlongSequence& _s)
{
  PortTypes::UlongSequence* _p = new PortTypes::UlongSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mUlongSequence,
               _0RL_PortTypes_mUlongSequence_marshal_fn,
               _0RL_PortTypes_mUlongSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::UlongSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mUlongSequence,
               _0RL_PortTypes_mUlongSequence_marshal_fn,
               _0RL_PortTypes_mUlongSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UlongSequence*& _sp)
{
  return _a >>= (const PortTypes::UlongSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UlongSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mUlongSequence,
                    _0RL_PortTypes_mUlongSequence_unmarshal_fn,
                    _0RL_PortTypes_mUlongSequence_marshal_fn,
                    _0RL_PortTypes_mUlongSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::UlongSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mUshortSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::UshortSequence* _p = (PortTypes::UshortSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mUshortSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::UshortSequence* _p = new PortTypes::UshortSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mUshortSequence_destructor_fn(void* _v)
{
  PortTypes::UshortSequence* _p = (PortTypes::UshortSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::UshortSequence& _s)
{
  PortTypes::UshortSequence* _p = new PortTypes::UshortSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mUshortSequence,
               _0RL_PortTypes_mUshortSequence_marshal_fn,
               _0RL_PortTypes_mUshortSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::UshortSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mUshortSequence,
               _0RL_PortTypes_mUshortSequence_marshal_fn,
               _0RL_PortTypes_mUshortSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UshortSequence*& _sp)
{
  return _a >>= (const PortTypes::UshortSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UshortSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mUshortSequence,
                    _0RL_PortTypes_mUshortSequence_unmarshal_fn,
                    _0RL_PortTypes_mUshortSequence_marshal_fn,
                    _0RL_PortTypes_mUshortSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::UshortSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mWcharSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::WcharSequence* _p = (PortTypes::WcharSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mWcharSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::WcharSequence* _p = new PortTypes::WcharSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mWcharSequence_destructor_fn(void* _v)
{
  PortTypes::WcharSequence* _p = (PortTypes::WcharSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::WcharSequence& _s)
{
  PortTypes::WcharSequence* _p = new PortTypes::WcharSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mWcharSequence,
               _0RL_PortTypes_mWcharSequence_marshal_fn,
               _0RL_PortTypes_mWcharSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::WcharSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mWcharSequence,
               _0RL_PortTypes_mWcharSequence_marshal_fn,
               _0RL_PortTypes_mWcharSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::WcharSequence*& _sp)
{
  return _a >>= (const PortTypes::WcharSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::WcharSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mWcharSequence,
                    _0RL_PortTypes_mWcharSequence_unmarshal_fn,
                    _0RL_PortTypes_mWcharSequence_marshal_fn,
                    _0RL_PortTypes_mWcharSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::WcharSequence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_PortTypes_mFloatSequence_marshal_fn(cdrStream& _s, void* _v)
{
  PortTypes::FloatSequence* _p = (PortTypes::FloatSequence*)_v;
  *_p >>= _s;
}
static void _0RL_PortTypes_mFloatSequence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  PortTypes::FloatSequence* _p = new PortTypes::FloatSequence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_PortTypes_mFloatSequence_destructor_fn(void* _v)
{
  PortTypes::FloatSequence* _p = (PortTypes::FloatSequence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const PortTypes::FloatSequence& _s)
{
  PortTypes::FloatSequence* _p = new PortTypes::FloatSequence(_s);
  _a.PR_insert(_0RL_tc_PortTypes_mFloatSequence,
               _0RL_PortTypes_mFloatSequence_marshal_fn,
               _0RL_PortTypes_mFloatSequence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, PortTypes::FloatSequence* _sp)
{
  _a.PR_insert(_0RL_tc_PortTypes_mFloatSequence,
               _0RL_PortTypes_mFloatSequence_marshal_fn,
               _0RL_PortTypes_mFloatSequence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::FloatSequence*& _sp)
{
  return _a >>= (const PortTypes::FloatSequence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::FloatSequence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_PortTypes_mFloatSequence,
                    _0RL_PortTypes_mFloatSequence_unmarshal_fn,
                    _0RL_PortTypes_mFloatSequence_marshal_fn,
                    _0RL_PortTypes_mFloatSequence_destructor_fn,
                    _v)) {
    _sp = (const PortTypes::FloatSequence*)_v;
    return 1;
  }
  return 0;
}

